/* Copyright (c) 2008 The Board of Trustees of The Leland Stanford Junior University */
/* Copyright (c) 2011, 2012 Open Networking Foundation */
/* Copyright (c) 2012, 2013 Big Switch Networks, Inc. */
/* See the file LICENSE.loci which should have been included in the source distribution */

/****************************************************************
 * File: loci_base.h
 *
 * DO NOT EDIT
 *
 * This file is automatically generated
 *
 ****************************************************************/


#if !defined(_LOCI_BASE_H_)
#define _LOCI_BASE_H_


/*
 * Base OpenFlow definitions.  These depend only on standard C headers
 */
#include <string.h>
#include <stdint.h>

/* g++ requires this to pick up PRI, etc.
 * See  http://gcc.gnu.org/ml/gcc-help/2006-10/msg00223.html
 */
#if !defined(__STDC_FORMAT_MACROS)
#define __STDC_FORMAT_MACROS
#endif
#include <inttypes.h>

#include <stdlib.h>
#include <assert.h>
#include <loci/loci_idents.h>

/**
 * Macro to enable debugging for LOCI.
 *
 * This enables debug output to stdout.
 */
#define OF_DEBUG_ENABLE

#if defined(OF_DEBUG_ENABLE)
#include <stdio.h> /* Currently for debugging */
#define FIXME(str) do {                 \
        fprintf(stderr, "%s\n", str);  \
        exit(1);                        \
    } while (0)
#define debug printf
#else
#define FIXME(str)
#define debug(str, ...)
#endif /* OF_DEBUG_ENABLE */

/**
 * The type of a function used by the LOCI dump/show functions to
 * output text. Essentially the same signature as fprintf. May
 * be called many times per invocation of e.g. of_object_show().
 */
typedef int (*loci_writer_f)(void *cookie, const char *fmt, ...);

/**
 * Check if a version is supported
 */
#define OF_VERSION_OKAY(v) ((v) >= OF_VERSION_1_0 && (v) <= OF_VERSION_1_3)


/**
 * Enumeration of OpenFlow versions
 *
 * The wire protocol numbers are currently used for values of the corresponding
 * version identifiers.
 */
typedef enum of_version_e {
    OF_VERSION_UNKNOWN = 0,
    OF_VERSION_1_0 = 1,
    OF_VERSION_1_1 = 2,
    OF_VERSION_1_2 = 3,
    OF_VERSION_1_3 = 4
} of_version_t;

/**
 * @brief Use this when declaring arrays indexed by wire version
 */
#define OF_VERSION_ARRAY_MAX 5


typedef enum of_error_codes_e {
    OF_ERROR_NONE        = 0,
    OF_ERROR_RESOURCE    = -1,    /* Could not allocate space */
    OF_ERROR_PARAM       = -2,    /* Bad parameter */
    OF_ERROR_VERSION     = -3,    /* Version not supported */
    OF_ERROR_RANGE       = -4,    /* End of list indication */
    OF_ERROR_COMPAT      = -5,    /* Incompatible assignment */
    OF_ERROR_PARSE       = -6,    /* Error in parsing data */
    OF_ERROR_INIT        = -7,    /* Uninitialized data */
    OF_ERROR_UNKNOWN     = -8     /* Unknown error */
} of_error_codes_t;

#define OF_ERROR_STRINGS "none", \
    "resource", \
    "parameter", \
    "version", \
    "range", \
    "incompatible", \
    "parse", \
    "init", \
    "unknown"

extern const char *const of_error_strings[];

#ifdef __GNUC__
#define LOCI_NORETURN_ATTR __attribute__((__noreturn__))
#else
#define LOCI_NORETURN_ATTR
#endif

extern void loci_assert_fail(
    const char *cond,
    const char *file,
    unsigned int line) LOCI_NORETURN_ATTR;

#ifndef NDEBUG
#define LOCI_ASSERT(val) ((val) ? (void)0 : loci_assert_fail(#val, __FILE__, __LINE__))
#else
#define LOCI_ASSERT(val)
#endif

/*
 * Some LOCI object accessors can fail, and it's easy to forget to check.
 * On certain compilers we can trigger a warning if the error code
 * is ignored.
 */
#ifndef DISABLE_WARN_UNUSED_RESULT
#ifdef __GNUC__
#define WARN_UNUSED_RESULT __attribute__ ((warn_unused_result))
#else
#define WARN_UNUSED_RESULT
#endif
#else
#define WARN_UNUSED_RESULT
#endif

typedef union of_generic_u of_generic_t;
typedef struct of_object_s of_object_t;

/* Define ipv4 address as uint32 */
typedef uint32_t of_ipv4_t;

/* Table ID is the OF standard uint8 */
typedef uint8_t of_table_id_t;

#define OF_MAC_ADDR_BYTES 6
typedef struct of_mac_addr_s {
   uint8_t addr[OF_MAC_ADDR_BYTES];
} of_mac_addr_t;

#define OF_IPV6_BYTES 16
typedef struct of_ipv6_s {
   uint8_t addr[OF_IPV6_BYTES];
} of_ipv6_t;

extern const of_mac_addr_t of_mac_addr_all_ones;
extern const of_mac_addr_t of_mac_addr_all_zeros;

extern const of_ipv6_t of_ipv6_all_ones;
extern const of_ipv6_t of_ipv6_all_zeros;

/**
 * Generic zero and all-ones values of size 16 bytes.
 *
 * IPv6 is longest data type we worry about for comparisons
 */
#define of_all_zero_value of_ipv6_all_zeros
#define of_all_ones_value of_ipv6_all_ones

/**
 * Non-zero/all ones check for arbitrary type of size <= 16 bytes
 */
#define OF_VARIABLE_IS_NON_ZERO(_ptr) \
    (MEMCMP(&of_all_zero_value, (_ptr), sizeof(*(_ptr))))
#define OF_VARIABLE_IS_ALL_ONES(_ptr) \
    (!MEMCMP(&of_all_ones_value, (_ptr), sizeof(*(_ptr))))

/* The octets object is a struct holding pointer and length */
typedef struct of_octets_s {
    uint8_t *data;
    int bytes;
} of_octets_t;

/* Macro to convert an octet object to a pointer; currently trivial */
#define OF_OCTETS_POINTER_GET(octet_ptr) ((octet_ptr)->data)
#define OF_OCTETS_POINTER_SET(octet_ptr, ptr) (octet_ptr)->data = (ptr)
#define OF_OCTETS_BYTES_GET(octet_ptr) ((octet_ptr)->bytes)
#define OF_OCTETS_BYTES_SET(octet_ptr, bytes) (octet_ptr)->bytes = (bytes)

/* Currently these are categorized as scalars */
typedef char of_port_name_t[OF_MAX_PORT_NAME_LEN];
typedef char of_table_name_t[OF_MAX_TABLE_NAME_LEN];
typedef char of_desc_str_t[OF_DESC_STR_LEN];
typedef char of_serial_num_t[OF_SERIAL_NUM_LEN];
typedef char of_str64_t[64];

typedef struct of_bitmap_128_s {
    uint64_t hi;
    uint64_t lo;
} of_bitmap_128_t;

typedef struct of_checksum_128_s {
    uint64_t hi;
    uint64_t lo;
} of_checksum_128_t;

/* These are types which change across versions.  */
typedef uint32_t of_port_no_t;
typedef uint16_t of_fm_cmd_t;
typedef uint64_t of_wc_bmap_t;
typedef uint64_t of_match_bmap_t;

#define MEMMOVE(dest, src, bytes) memmove(dest, src, bytes)
#define MEMSET(dest, val, bytes) memset(dest, val, bytes)
#define MEMCPY(dest, src, bytes) memcpy(dest, src, bytes)
#define MEMCMP(a, b, bytes) memcmp(a, b, bytes)
#define MALLOC(bytes) malloc(bytes)
#define FREE(ptr) free(ptr)

/** Try an operation and return on failure. */
#define OF_TRY(op) do {                                                      \
        int _rv;                                                             \
        if ((_rv = (op)) < 0) {                                              \
            LOCI_LOG_ERROR("ERROR %d at %s:%d\n", _rv, __FILE__, __LINE__); \
            return _rv;                                                      \
        }                                                                    \
    } while (0)

/* The extent of an OF match object is determined by its length field, but
 * aligned to 8 bytes
 */

#define OF_MATCH_BYTES(length) (((length) + 7) & 0xfff8)

#if __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__
#define U16_NTOH(val) (val)
#define U32_NTOH(val) (val)
#define U64_NTOH(val) (val)
#define IPV6_NTOH(dst, src) /* NOTE different syntax; currently no-op */
#define U16_HTON(val) (val)
#define U32_HTON(val) (val)
#define U64_HTON(val) (val)
#define IPV6_HTON(dst, src) /* NOTE different syntax; currently no-op */
#else /* Little Endian */
#define U16_NTOH(val) (((val) >> 8) | (((val) & 0xff) << 8))
#define U32_NTOH(val) ((((val) & 0xff000000) >> 24) |                   \
                       (((val) & 0x00ff0000) >>  8) |                   \
                       (((val) & 0x0000ff00) <<  8) |                   \
                       (((val) & 0x000000ff) << 24))
#define U64_NTOH(val) ((((val) & 0xff00000000000000LL) >> 56) |         \
                       (((val) & 0x00ff000000000000LL) >> 40) |         \
                       (((val) & 0x0000ff0000000000LL) >> 24) |         \
                       (((val) & 0x000000ff00000000LL) >>  8) |         \
                       (((val) & 0x00000000ff000000LL) <<  8) |         \
                       (((val) & 0x0000000000ff0000LL) << 24) |         \
                       (((val) & 0x000000000000ff00LL) << 40) |         \
                       (((val) & 0x00000000000000ffLL) << 56))
#define IPV6_NTOH(dst, src) /* NOTE different syntax; currently no-op */
#define U16_HTON(val) U16_NTOH(val)
#define U32_HTON(val) U32_NTOH(val)
#define U64_HTON(val) U64_NTOH(val)
#define IPV6_HTON(dst, src) /* NOTE different syntax; currently no-op */
#endif

/****************************************************************
 *
 * The following are internal definitions used by the automatically
 * generated code.  Users should not reference these definitions
 * as they may change between versions of this code
 *
 ****************************************************************/

#define OF_MESSAGE_IN_MATCH_POINTER(obj)                            \
    (WIRE_BUF_POINTER(&((obj)->wire_buffer), OF_MESSAGE_IN_MATCH_OFFSET))
#define OF_MESSAGE_IN_MATCH_LEN(ptr) BUF_U16_GET(&ptr[2])
#define OF_MESSAGE_IN_DATA_OFFSET(obj) \
    (FIXED_LEN + OF_MESSAGE_IN_MATCH_LEN(OF_MESSAGE_IN_MATCH_POINTER(obj)) + 2)

#define OF_MESSAGE_OUT_DATA_OFFSET(obj) \
    (FIXED_LEN + of_message_out_actions_len_get(obj))

/* Added by JiaoYong, 2017/4/6 */
#define MULTIPART_EXPERIMENTER_ID   0xFF00000A
#define MULTIPART_EXPERIMENTER_TYPE 0xFF000001
typedef enum of_dev_feature_id_e {
MPLS_TP_Service_L2VPN_VPWS_MSPW = 0x00000000, 
MPLS_TP_Service_L2VPN_VPLS_MSPW,
MPLS_TP_Service_L3VPN,
MPLS_TP_Service_END,

MPLS_TP_OAM_G_8113_1_OAM = 0x01000000,
MPLS_TP_OAM_G_8113_1_OAM_CCM,
MPLS_TP_OAM_G_8113_1_OAM_PM,
MPLS_TP_OAM_G_8113_2_OAM_BFD,
MPLS_TP_OAM_G_8113_2_OAM_LSP_Ping_Ext,
MPLS_TP_OAM_MPLS_OAM_PW_Ping,
MPLS_TP_OAM_MPLS_OAM_PW_Traceroute,
MPLS_TP_OAM_MPLS_OAM_LSP_Ping,
MPLS_TP_OAM_MPLS_OAM_LSP_Traceroute,
MPLS_TP_OAM_END,

QoS_H_CAR = 0x02000000,
QoS_H_QoS,
QoS_END,

LAG_Protection_Basic_LAG = 0x03000000,
LAG_Protection_MC_LAG,
MPLS_TP_Linear_Protection_LSP_Protection_1_TO_1,
MPLS_TP_Linear_Protection_LSP_Protection_1_PLUS_1,
MPLS_TP_Linear_Protection_LSP_Protection_1_TO_n,
MPLS_TP_Linear_Protection_PW_Protecion_1_TO_1,
MPLS_TP_Linear_Protection_PW_Protecion_1_PLUS_1,
MPLS_TP_Linear_Protection_PW_Protecion_1_TO_n,
MPLS_TP_Linear_Protection_LSP_and_PW_overlay_Protection,
MPLS_TP_Ring_Protection_Wrapping,
MPLS_TP_Ring_Protection_Steering,
Protection_END,

Test_Y1564 = 0x04000000,
Test_RFC2544,
Test_TWAMP_TWAMP_Lite,
Test_TWAMP_All,
Test_ICMP,
Test_Loopback,
Test_END,

Statistics_Port = 0x05000000,
Statistics_AC,
Statistics_PW,
Statistics_LSP,
Statistics_END,

Time_SNTP = 0x06000000,
Time_NTP,
Time_SyncE,
Time_IEEE1588v2_TC_only,
Time_IEEE1588v2_All,
Time_END,

System_Peformance_Monitor_CPU_Monitor = 0x07000000,
System_Peformance_Monitor_Memory_Monitor,
System_Peformance_Monitor_Temperature_Monitor,
System_Peformance_Monitor_SFP_Monitor,
System_Peformance_Monitor_END,


Security_Management_RADIUS = 0x08000000,
Security_Management_TACACS_PLUS,
Security_Management_END

} of_dev_feature_id_t;
#define DEV_FEATURE_CNT ( \
    (MPLS_TP_Service_END - MPLS_TP_Service_L2VPN_VPWS_MSPW) \
    + (MPLS_TP_OAM_END - MPLS_TP_OAM_G_8113_1_OAM) \
    + (QoS_END - QoS_H_CAR) \
    + (Protection_END - LAG_Protection_Basic_LAG) \
    + (Test_END - Test_Y1564) \
    + (Statistics_END - Statistics_Port) \
    + (Time_END - Time_SNTP) \
    + (System_Peformance_Monitor_END - System_Peformance_Monitor_CPU_Monitor) \
    + (Security_Management_END - Security_Management_RADIUS) \
    )
    

/**
 * Enumeration of OpenFlow objects
 *
 * We enumerate the OpenFlow objects used internally.  Note that some
 * message types are determined both by an outer type (message type like
 * stats_request) and an inner type (port stats).  These are different
 * messages in ofC.
 *
 * These values are for internal use only.  They will change with
 * different versions of ofC.
 */

typedef enum of_object_id_e {
    /* Root object type */
    OF_OBJECT_INVALID = -1, /* "invalid" return value for mappings */
    OF_OBJECT = 0, /* Generic, untyped object */

    /* OpenFlow message objects */
    OF_AGGREGATE_STATS_REPLY = 1,
    OF_AGGREGATE_STATS_REQUEST = 2,
    OF_ASYNC_GET_REPLY = 3,
    OF_ASYNC_GET_REQUEST = 4,
    OF_ASYNC_SET = 5,
    OF_BAD_ACTION_ERROR_MSG = 6,
    OF_BAD_INSTRUCTION_ERROR_MSG = 7,
    OF_BAD_MATCH_ERROR_MSG = 8,
    OF_BAD_REQUEST_ERROR_MSG = 9,
    OF_BARRIER_REPLY = 10,
    OF_BARRIER_REQUEST = 11,
    OF_BSN_ARP_IDLE = 12,
    OF_BSN_BW_CLEAR_DATA_REPLY = 13,
    OF_BSN_BW_CLEAR_DATA_REQUEST = 14,
    OF_BSN_BW_ENABLE_GET_REPLY = 15,
    OF_BSN_BW_ENABLE_GET_REQUEST = 16,
    OF_BSN_BW_ENABLE_SET_REPLY = 17,
    OF_BSN_BW_ENABLE_SET_REQUEST = 18,
    OF_BSN_CONTROLLER_CONNECTIONS_REPLY = 19,
    OF_BSN_CONTROLLER_CONNECTIONS_REQUEST = 20,
    OF_BSN_DEBUG_COUNTER_DESC_STATS_REPLY = 21,
    OF_BSN_DEBUG_COUNTER_DESC_STATS_REQUEST = 22,
    OF_BSN_DEBUG_COUNTER_STATS_REPLY = 23,
    OF_BSN_DEBUG_COUNTER_STATS_REQUEST = 24,
    OF_BSN_FLOW_CHECKSUM_BUCKET_STATS_REPLY = 25,
    OF_BSN_FLOW_CHECKSUM_BUCKET_STATS_REQUEST = 26,
    OF_BSN_FLOW_IDLE = 27,
    OF_BSN_FLOW_IDLE_ENABLE_GET_REPLY = 28,
    OF_BSN_FLOW_IDLE_ENABLE_GET_REQUEST = 29,
    OF_BSN_FLOW_IDLE_ENABLE_SET_REPLY = 30,
    OF_BSN_FLOW_IDLE_ENABLE_SET_REQUEST = 31,
    OF_BSN_GENTABLE_BUCKET_STATS_REPLY = 32,
    OF_BSN_GENTABLE_BUCKET_STATS_REQUEST = 33,
    OF_BSN_GENTABLE_CLEAR_REPLY = 34,
    OF_BSN_GENTABLE_CLEAR_REQUEST = 35,
    OF_BSN_GENTABLE_DESC_STATS_REPLY = 36,
    OF_BSN_GENTABLE_DESC_STATS_REQUEST = 37,
    OF_BSN_GENTABLE_ENTRY_ADD = 38,
    OF_BSN_GENTABLE_ENTRY_DELETE = 39,
    OF_BSN_GENTABLE_ENTRY_DESC_STATS_REPLY = 40,
    OF_BSN_GENTABLE_ENTRY_DESC_STATS_REQUEST = 41,
    OF_BSN_GENTABLE_ENTRY_STATS_REPLY = 42,
    OF_BSN_GENTABLE_ENTRY_STATS_REQUEST = 43,
    OF_BSN_GENTABLE_SET_BUCKETS_SIZE = 44,
    OF_BSN_GENTABLE_STATS_REPLY = 45,
    OF_BSN_GENTABLE_STATS_REQUEST = 46,
    OF_BSN_GET_INTERFACES_REPLY = 47,
    OF_BSN_GET_INTERFACES_REQUEST = 48,
    OF_BSN_GET_IP_MASK_REPLY = 49,
    OF_BSN_GET_IP_MASK_REQUEST = 50,
    OF_BSN_GET_L2_TABLE_REPLY = 51,
    OF_BSN_GET_L2_TABLE_REQUEST = 52,
    OF_BSN_GET_MIRRORING_REPLY = 53,
    OF_BSN_GET_MIRRORING_REQUEST = 54,
    OF_BSN_GET_SWITCH_PIPELINE_REPLY = 55,
    OF_BSN_GET_SWITCH_PIPELINE_REQUEST = 56,
    OF_BSN_HEADER = 57,
    OF_BSN_HYBRID_GET_REPLY = 58,
    OF_BSN_HYBRID_GET_REQUEST = 59,
    OF_BSN_LACP_CONVERGENCE_NOTIF = 60,
    OF_BSN_LACP_STATS_REPLY = 61,
    OF_BSN_LACP_STATS_REQUEST = 62,
    OF_BSN_PDU_RX_REPLY = 63,
    OF_BSN_PDU_RX_REQUEST = 64,
    OF_BSN_PDU_RX_TIMEOUT = 65,
    OF_BSN_PDU_TX_REPLY = 66,
    OF_BSN_PDU_TX_REQUEST = 67,
    OF_BSN_PORT_COUNTER_STATS_REPLY = 68,
    OF_BSN_PORT_COUNTER_STATS_REQUEST = 69,
    OF_BSN_ROLE_STATUS = 70,
    OF_BSN_SET_AUX_CXNS_REPLY = 71,
    OF_BSN_SET_AUX_CXNS_REQUEST = 72,
    OF_BSN_SET_IP_MASK = 73,
    OF_BSN_SET_L2_TABLE_REPLY = 74,
    OF_BSN_SET_L2_TABLE_REQUEST = 75,
    OF_BSN_SET_LACP_REPLY = 76,
    OF_BSN_SET_LACP_REQUEST = 77,
    OF_BSN_SET_MIRRORING = 78,
    OF_BSN_SET_PKTIN_SUPPRESSION_REPLY = 79,
    OF_BSN_SET_PKTIN_SUPPRESSION_REQUEST = 80,
    OF_BSN_SET_SWITCH_PIPELINE_REPLY = 81,
    OF_BSN_SET_SWITCH_PIPELINE_REQUEST = 82,
    OF_BSN_SHELL_COMMAND = 83,
    OF_BSN_SHELL_OUTPUT = 84,
    OF_BSN_SHELL_STATUS = 85,
    OF_BSN_STATS_REPLY = 86,
    OF_BSN_STATS_REQUEST = 87,
    OF_BSN_SWITCH_PIPELINE_STATS_REPLY = 88,
    OF_BSN_SWITCH_PIPELINE_STATS_REQUEST = 89,
    OF_BSN_TABLE_CHECKSUM_STATS_REPLY = 90,
    OF_BSN_TABLE_CHECKSUM_STATS_REQUEST = 91,
    OF_BSN_TABLE_SET_BUCKETS_SIZE = 92,
    OF_BSN_TIME_REPLY = 93,
    OF_BSN_TIME_REQUEST = 94,
    OF_BSN_VIRTUAL_PORT_CREATE_REPLY = 95,
    OF_BSN_VIRTUAL_PORT_CREATE_REQUEST = 96,
    OF_BSN_VIRTUAL_PORT_REMOVE_REPLY = 97,
    OF_BSN_VIRTUAL_PORT_REMOVE_REQUEST = 98,
    OF_BSN_VLAN_COUNTER_STATS_REPLY = 99,
    OF_BSN_VLAN_COUNTER_STATS_REQUEST = 100,
    OF_DESC_STATS_REPLY = 101,
    OF_DESC_STATS_REQUEST = 102,
    OF_ECHO_REPLY = 103,
    OF_ECHO_REQUEST = 104,
    OF_ERROR_MSG = 105,
    OF_EXPERIMENTER = 106,
    OF_EXPERIMENTER_ERROR_MSG = 107,
    OF_EXPERIMENTER_MULTIPART_REPLY_OFDPA = 108,
    OF_EXPERIMENTER_MULTIPART_REQUEST_OFDPA = 109,
    OF_EXPERIMENTER_OFDPA = 110,
    OF_EXPERIMENTER_STATS_REPLY = 111,
    OF_EXPERIMENTER_STATS_REQUEST = 112,
    OF_FEATURES_REPLY = 113,
    OF_FEATURES_REQUEST = 114,
    OF_FLOW_ADD = 115,
    OF_FLOW_DELETE = 116,
    OF_FLOW_DELETE_STRICT = 117,
    OF_FLOW_MOD = 118,
    OF_FLOW_MOD_FAILED_ERROR_MSG = 119,
    OF_FLOW_MODIFY = 120,
    OF_FLOW_MODIFY_STRICT = 121,
    OF_FLOW_REMOVED = 122,
    OF_FLOW_STATS_REPLY = 123,
    OF_FLOW_STATS_REQUEST = 124,
    OF_GET_CONFIG_REPLY = 125,
    OF_GET_CONFIG_REQUEST = 126,
    OF_GROUP_ADD = 127,
    OF_GROUP_DELETE = 128,
    OF_GROUP_DESC_STATS_REPLY = 129,
    OF_GROUP_DESC_STATS_REQUEST = 130,
    OF_GROUP_FEATURES_STATS_REPLY = 131,
    OF_GROUP_FEATURES_STATS_REQUEST = 132,
    OF_GROUP_MOD = 133,
    OF_GROUP_MOD_FAILED_ERROR_MSG = 134,
    OF_GROUP_MODIFY = 135,
    OF_GROUP_STATS_REPLY = 136,
    OF_GROUP_STATS_REQUEST = 137,
    OF_HELLO = 138,
    OF_HELLO_FAILED_ERROR_MSG = 139,
    OF_METER_ADD = 140,
    OF_METER_CONFIG_STATS_REPLY = 141,
    OF_METER_CONFIG_STATS_REQUEST = 142,
    OF_METER_DELETE = 143,
    OF_METER_FEATURES_STATS_REPLY = 144,
    OF_METER_FEATURES_STATS_REQUEST = 145,
    OF_METER_MOD = 146,
    OF_METER_MOD_FAILED_ERROR_MSG = 147,
    OF_METER_MODIFY = 148,
    OF_METER_STATS_REPLY = 149,
    OF_METER_STATS_REQUEST = 150,
    OF_NICIRA_CONTROLLER_ROLE_REPLY = 151,
    OF_NICIRA_CONTROLLER_ROLE_REQUEST = 152,
    OF_NICIRA_HEADER = 153,
    OF_OFDPA_CLASS_BASED_CTR_MOD_MSG = 154,
    OF_OFDPA_CLASS_BASED_CTR_MULTIPART_REPLY = 155,
    OF_OFDPA_CLASS_BASED_CTR_MULTIPART_REQUEST = 156,
    OF_OFDPA_COLOR_BASED_CTR_MOD_MSG = 157,
    OF_OFDPA_COLOR_BASED_CTR_MULTIPART_REPLY = 158,
    OF_OFDPA_COLOR_BASED_CTR_MULTIPART_REQUEST = 159,
    OF_OFDPA_L2_INTERFACE_REMARK_ACTION_MOD_MSG = 160,
    OF_OFDPA_L2_INTERFACE_REMARK_ACTION_MULTIPART_REPLY = 161,
    OF_OFDPA_L2_INTERFACE_REMARK_ACTION_MULTIPART_REQUEST = 162,
    OF_OFDPA_MPLS_TUNNEL_LABEL_MULTIPART_REPLY = 163,
    OF_OFDPA_MPLS_TUNNEL_LABEL_MULTIPART_REQUEST = 164,
    OF_OFDPA_MPLS_TUNNEL_LABEL_REMARK_ACTION_MOD_MSG = 165,
    OF_OFDPA_MPLS_VPN_LABEL_REMARK_ACTION_MOD_MSG = 166,
    OF_OFDPA_MPLS_VPN_LABEL_REMARK_ACTION_MULTIPART_REPLY = 167,
    OF_OFDPA_MPLS_VPN_LABEL_REMARK_ACTION_MULTIPART_REQUEST = 168,
    OF_OFDPA_OAM_DATAPLANE_CTR_MOD_MSG = 169,
    OF_OFDPA_OAM_DATAPLANE_CTR_MULTIPART_REPLY = 170,
    OF_OFDPA_OAM_DATAPLANE_CTR_MULTIPART_REQUEST = 171,
    OF_OFDPA_OAM_DROP_STATUS_MOD_MSG = 172,
    OF_OFDPA_OAM_DROP_STATUS_MULTIPART_REPLY = 173,
    OF_OFDPA_OAM_DROP_STATUS_MULTIPART_REQUEST = 174,
    OF_OFDPA_PORT_EXPERIMENTER_PROP_SCHEDULING = 175,
    OF_OFDPA_QUEUE_DESC_PROP_CONGESTION_MULTIPART_REPLY = 176,
    OF_OFDPA_QUEUE_DESC_PROP_CONGESTION_MULTIPART_REQUEST = 177,
    OF_OFDPA_QUEUE_DESC_PROP_PARENT_MULTIPART_REPLY = 178,
    OF_OFDPA_QUEUE_DESC_PROP_PARENT_MULTIPART_REQUEST = 179,
    OF_OFDPA_QUEUE_MOD = 180,
    OF_OFDPA_SCHEDULER_NODE_MOD_MSG = 181,
    OF_OFDPA_SCHEDULER_NODE_MULTIPART_REQUEST = 182,
    OF_OFDPA_SCHEDULER_NODE_MULTIPART_RESPONSE = 183,
    OF_PACKET_IN = 184,
    OF_PACKET_OUT = 185,
    OF_PORT_DESC_STATS_REPLY = 186,
    OF_PORT_DESC_STATS_REQUEST = 187,
    OF_PORT_MOD = 188,
    OF_PORT_MOD_FAILED_ERROR_MSG = 189,
    OF_PORT_STATS_REPLY = 190,
    OF_PORT_STATS_REQUEST = 191,
    OF_PORT_STATUS = 192,
    OF_QUEUE_GET_CONFIG_REPLY = 193,
    OF_QUEUE_GET_CONFIG_REQUEST = 194,
    OF_QUEUE_OP_FAILED_ERROR_MSG = 195,
    OF_QUEUE_STATS_REPLY = 196,
    OF_QUEUE_STATS_REQUEST = 197,
    OF_ROLE_REPLY = 198,
    OF_ROLE_REQUEST = 199,
    OF_ROLE_REQUEST_FAILED_ERROR_MSG = 200,
    OF_SET_CONFIG = 201,
    OF_STATS_REPLY = 202,
    OF_STATS_REQUEST = 203,
    OF_SWITCH_CONFIG_FAILED_ERROR_MSG = 204,
    OF_TABLE_FEATURES_FAILED_ERROR_MSG = 205,
    OF_TABLE_FEATURES_STATS_REPLY = 206,
    OF_TABLE_FEATURES_STATS_REQUEST = 207,
    OF_TABLE_MOD = 208,
    OF_TABLE_MOD_FAILED_ERROR_MSG = 209,
    OF_TABLE_STATS_REPLY = 210,
    OF_TABLE_STATS_REQUEST = 211,

    /* Non-message objects */
    OF_ACTION = 212,
    OF_ACTION_BSN = 213,
    OF_ACTION_BSN_MIRROR = 214,
    OF_ACTION_BSN_SET_TUNNEL_DST = 215,
    OF_ACTION_COPY_TTL_IN = 216,
    OF_ACTION_COPY_TTL_OUT = 217,
    OF_ACTION_DEC_MPLS_TTL = 218,
    OF_ACTION_DEC_NW_TTL = 219,
    OF_ACTION_ENQUEUE = 220,
    OF_ACTION_EXPERIMENTER = 221,
    OF_ACTION_GROUP = 222,
    OF_ACTION_HEADER = 223,
    OF_ACTION_ID = 224,
    OF_ACTION_ID_BSN = 225,
    OF_ACTION_ID_BSN_MIRROR = 226,
    OF_ACTION_ID_BSN_SET_TUNNEL_DST = 227,
    OF_ACTION_ID_COPY_TTL_IN = 228,
    OF_ACTION_ID_COPY_TTL_OUT = 229,
    OF_ACTION_ID_DEC_MPLS_TTL = 230,
    OF_ACTION_ID_DEC_NW_TTL = 231,
    OF_ACTION_ID_EXPERIMENTER = 232,
    OF_ACTION_ID_GROUP = 233,
    OF_ACTION_ID_HEADER = 234,
    OF_ACTION_ID_NICIRA = 235,
    OF_ACTION_ID_NICIRA_DEC_TTL = 236,
    OF_ACTION_ID_OFDPA = 237,
    OF_ACTION_ID_OFDPA_CHECK_DROP_STATUS = 238,
    OF_ACTION_ID_OFDPA_CLASS_BASED_COUNT = 239,
    OF_ACTION_ID_OFDPA_COLOR_BASED_COUNT = 240,
    OF_ACTION_ID_OFDPA_COLOR_BASED_COUNT_1 = 241,
    OF_ACTION_ID_OFDPA_COLOR_BASED_COUNT_2 = 242,
    OF_ACTION_ID_OFDPA_COLOR_BASED_COUNT_3 = 243,
    OF_ACTION_ID_OFDPA_COPY_TC_IN = 244,
    OF_ACTION_ID_OFDPA_COPY_TC_OUT = 245,
    OF_ACTION_ID_OFDPA_DEC_TTL_MTU = 246,
    OF_ACTION_ID_OFDPA_OAM_LM_RX_COUNT = 247,
    OF_ACTION_ID_OFDPA_OAM_LM_TX_COUNT = 248,
    OF_ACTION_ID_OFDPA_POP_CW = 249,
    OF_ACTION_ID_OFDPA_POP_L2HDR = 250,
    OF_ACTION_ID_OFDPA_PUSH_CW = 251,
    OF_ACTION_ID_OFDPA_PUSH_L2HDR = 252,
    OF_ACTION_ID_OFDPA_SET_COUNTER_FIELDS = 253,
    OF_ACTION_ID_OFDPA_SET_MPLS_PCPDEI_FROM_TABLE = 254,
    OF_ACTION_ID_OFDPA_SET_MPLS_PCPDEI_FROM_TUNNEL_TABLE = 255,
    OF_ACTION_ID_OFDPA_SET_MPLS_TC_FROM_TUNNEL_TABLE = 256,
    OF_ACTION_ID_OFDPA_SET_MPLS_TC_FROM_VPN_TABLE = 257,
    OF_ACTION_ID_OFDPA_SET_PCPDEI_FROM_TABLE = 258,
    OF_ACTION_ID_ONF = 259,
    OF_ACTION_ID_ONF_COPY_FIELD = 260,
    OF_ACTION_ID_OUTPUT = 261,
    OF_ACTION_ID_POP_MPLS = 262,
    OF_ACTION_ID_POP_PBB = 263,
    OF_ACTION_ID_POP_VLAN = 264,
    OF_ACTION_ID_PUSH_MPLS = 265,
    OF_ACTION_ID_PUSH_PBB = 266,
    OF_ACTION_ID_PUSH_VLAN = 267,
    OF_ACTION_ID_SET_FIELD = 268,
    OF_ACTION_ID_SET_MPLS_TTL = 269,
    OF_ACTION_ID_SET_NW_TTL = 270,
    OF_ACTION_ID_SET_QUEUE = 271,
    OF_ACTION_NICIRA = 272,
    OF_ACTION_NICIRA_DEC_TTL = 273,
    OF_ACTION_OFDPA = 274,
    OF_ACTION_OFDPA_CHECK_DROP_STATUS = 275,
    OF_ACTION_OFDPA_CLASS_BASED_COUNT = 276,
    OF_ACTION_OFDPA_COLOR_BASED_COUNT = 277,
    OF_ACTION_OFDPA_COLOR_BASED_COUNT_1 = 278,
    OF_ACTION_OFDPA_COLOR_BASED_COUNT_2 = 279,
    OF_ACTION_OFDPA_COLOR_BASED_COUNT_3 = 280,
    OF_ACTION_OFDPA_COPY_TC_IN = 281,
    OF_ACTION_OFDPA_COPY_TC_OUT = 282,
    OF_ACTION_OFDPA_DEC_TTL_MTU = 283,
    OF_ACTION_OFDPA_OAM_LM_RX_COUNT = 284,
    OF_ACTION_OFDPA_OAM_LM_TX_COUNT = 285,
    OF_ACTION_OFDPA_POP_CW = 286,
    OF_ACTION_OFDPA_POP_L2HDR = 287,
    OF_ACTION_OFDPA_PUSH_CW = 288,
    OF_ACTION_OFDPA_PUSH_L2HDR = 289,
    OF_ACTION_OFDPA_SET_COUNTER_FIELDS = 290,
    OF_ACTION_OFDPA_SET_MPLS_PCPDEI_FROM_TABLE = 291,
    OF_ACTION_OFDPA_SET_MPLS_PCPDEI_FROM_TUNNEL_TABLE = 292,
    OF_ACTION_OFDPA_SET_MPLS_TC_FROM_TUNNEL_TABLE = 293,
    OF_ACTION_OFDPA_SET_MPLS_TC_FROM_VPN_TABLE = 294,
    OF_ACTION_OFDPA_SET_PCPDEI_FROM_TABLE = 295,
    OF_ACTION_ONF = 296,
    OF_ACTION_ONF_COPY_FIELD = 297,
    OF_ACTION_OUTPUT = 298,
    OF_ACTION_POP_MPLS = 299,
    OF_ACTION_POP_PBB = 300,
    OF_ACTION_POP_VLAN = 301,
    OF_ACTION_PUSH_MPLS = 302,
    OF_ACTION_PUSH_PBB = 303,
    OF_ACTION_PUSH_VLAN = 304,
    OF_ACTION_SET_DL_DST = 305,
    OF_ACTION_SET_DL_SRC = 306,
    OF_ACTION_SET_FIELD = 307,
    OF_ACTION_SET_MPLS_LABEL = 308,
    OF_ACTION_SET_MPLS_TC = 309,
    OF_ACTION_SET_MPLS_TTL = 310,
    OF_ACTION_SET_NW_DST = 311,
    OF_ACTION_SET_NW_ECN = 312,
    OF_ACTION_SET_NW_SRC = 313,
    OF_ACTION_SET_NW_TOS = 314,
    OF_ACTION_SET_NW_TTL = 315,
    OF_ACTION_SET_QUEUE = 316,
    OF_ACTION_SET_TP_DST = 317,
    OF_ACTION_SET_TP_SRC = 318,
    OF_ACTION_SET_VLAN_PCP = 319,
    OF_ACTION_SET_VLAN_VID = 320,
    OF_ACTION_STRIP_VLAN = 321,
    OF_BSN_CONTROLLER_CONNECTION = 322,
    OF_BSN_DEBUG_COUNTER_DESC_STATS_ENTRY = 323,
    OF_BSN_DEBUG_COUNTER_STATS_ENTRY = 324,
    OF_BSN_FLOW_CHECKSUM_BUCKET_STATS_ENTRY = 325,
    OF_BSN_GENTABLE_BUCKET_STATS_ENTRY = 326,
    OF_BSN_GENTABLE_DESC_STATS_ENTRY = 327,
    OF_BSN_GENTABLE_ENTRY_DESC_STATS_ENTRY = 328,
    OF_BSN_GENTABLE_ENTRY_STATS_ENTRY = 329,
    OF_BSN_GENTABLE_STATS_ENTRY = 330,
    OF_BSN_INTERFACE = 331,
    OF_BSN_LACP_STATS_ENTRY = 332,
    OF_BSN_PORT_COUNTER_STATS_ENTRY = 333,
    OF_BSN_SWITCH_PIPELINE_STATS_ENTRY = 334,
    OF_BSN_TABLE_CHECKSUM_STATS_ENTRY = 335,
    OF_BSN_TLV = 336,
    OF_BSN_TLV_BROADCAST_QUERY_TIMEOUT = 337,
    OF_BSN_TLV_CIRCUIT_ID = 338,
    OF_BSN_TLV_HEADER = 339,
    OF_BSN_TLV_IDLE_NOTIFICATION = 340,
    OF_BSN_TLV_IDLE_TIME = 341,
    OF_BSN_TLV_IDLE_TIMEOUT = 342,
    OF_BSN_TLV_IPV4 = 343,
    OF_BSN_TLV_MAC = 344,
    OF_BSN_TLV_MISS_PACKETS = 345,
    OF_BSN_TLV_PORT = 346,
    OF_BSN_TLV_REPLY_PACKETS = 347,
    OF_BSN_TLV_REQUEST_PACKETS = 348,
    OF_BSN_TLV_RX_PACKETS = 349,
    OF_BSN_TLV_TX_PACKETS = 350,
    OF_BSN_TLV_UDF_ANCHOR = 351,
    OF_BSN_TLV_UDF_ID = 352,
    OF_BSN_TLV_UDF_LENGTH = 353,
    OF_BSN_TLV_UDF_OFFSET = 354,
    OF_BSN_TLV_UNICAST_QUERY_TIMEOUT = 355,
    OF_BSN_TLV_VLAN_VID = 356,
    OF_BSN_VLAN_COUNTER_STATS_ENTRY = 357,
    OF_BSN_VPORT = 358,
    OF_BSN_VPORT_HEADER = 359,
    OF_BSN_VPORT_Q_IN_Q = 360,
    OF_BUCKET = 361,
    OF_BUCKET_COUNTER = 362,
    OF_FLOW_STATS_ENTRY = 363,
    OF_GROUP_DESC_STATS_ENTRY = 364,
    OF_GROUP_STATS_ENTRY = 365,
    OF_HEADER = 366,
    OF_HELLO_ELEM = 367,
    OF_HELLO_ELEM_HEADER = 368,
    OF_HELLO_ELEM_VERSIONBITMAP = 369,
    OF_INSTRUCTION = 370,
    OF_INSTRUCTION_APPLY_ACTIONS = 371,
    OF_INSTRUCTION_BSN = 372,
    OF_INSTRUCTION_BSN_ARP_OFFLOAD = 373,
    OF_INSTRUCTION_BSN_DENY = 374,
    OF_INSTRUCTION_BSN_DHCP_OFFLOAD = 375,
    OF_INSTRUCTION_BSN_DISABLE_SPLIT_HORIZON_CHECK = 376,
    OF_INSTRUCTION_BSN_DISABLE_SRC_MAC_CHECK = 377,
    OF_INSTRUCTION_BSN_PACKET_OF_DEATH = 378,
    OF_INSTRUCTION_BSN_PERMIT = 379,
    OF_INSTRUCTION_CLEAR_ACTIONS = 380,
    OF_INSTRUCTION_EXPERIMENTER = 381,
    OF_INSTRUCTION_GOTO_TABLE = 382,
    OF_INSTRUCTION_HEADER = 383,
    OF_INSTRUCTION_ID = 384,
    OF_INSTRUCTION_ID_APPLY_ACTIONS = 385,
    OF_INSTRUCTION_ID_BSN = 386,
    OF_INSTRUCTION_ID_BSN_ARP_OFFLOAD = 387,
    OF_INSTRUCTION_ID_BSN_DENY = 388,
    OF_INSTRUCTION_ID_BSN_DHCP_OFFLOAD = 389,
    OF_INSTRUCTION_ID_BSN_DISABLE_SPLIT_HORIZON_CHECK = 390,
    OF_INSTRUCTION_ID_BSN_DISABLE_SRC_MAC_CHECK = 391,
    OF_INSTRUCTION_ID_BSN_PACKET_OF_DEATH = 392,
    OF_INSTRUCTION_ID_BSN_PERMIT = 393,
    OF_INSTRUCTION_ID_CLEAR_ACTIONS = 394,
    OF_INSTRUCTION_ID_EXPERIMENTER = 395,
    OF_INSTRUCTION_ID_GOTO_TABLE = 396,
    OF_INSTRUCTION_ID_HEADER = 397,
    OF_INSTRUCTION_ID_METER = 398,
    OF_INSTRUCTION_ID_WRITE_ACTIONS = 399,
    OF_INSTRUCTION_ID_WRITE_METADATA = 400,
    OF_INSTRUCTION_METER = 401,
    OF_INSTRUCTION_WRITE_ACTIONS = 402,
    OF_INSTRUCTION_WRITE_METADATA = 403,
    OF_MATCH_V1 = 404,
    OF_MATCH_V2 = 405,
    OF_MATCH_V3 = 406,
    OF_METER_BAND = 407,
    OF_METER_BAND_DROP = 408,
    OF_METER_BAND_DSCP_REMARK = 409,
    OF_METER_BAND_EXPERIMENTER = 410,
    OF_METER_BAND_HEADER = 411,
    OF_METER_BAND_OFDPA_COLOR_SET = 412,
    OF_METER_BAND_STATS = 413,
    OF_METER_CONFIG = 414,
    OF_METER_FEATURES = 415,
    OF_METER_STATS = 416,
    OF_OXM = 417,
    OF_OXM_ARP_OP = 418,
    OF_OXM_ARP_OP_MASKED = 419,
    OF_OXM_ARP_SHA = 420,
    OF_OXM_ARP_SHA_MASKED = 421,
    OF_OXM_ARP_SPA = 422,
    OF_OXM_ARP_SPA_MASKED = 423,
    OF_OXM_ARP_THA = 424,
    OF_OXM_ARP_THA_MASKED = 425,
    OF_OXM_ARP_TPA = 426,
    OF_OXM_ARP_TPA_MASKED = 427,
    OF_OXM_BSN_EGR_PORT_GROUP_ID = 428,
    OF_OXM_BSN_EGR_PORT_GROUP_ID_MASKED = 429,
    OF_OXM_BSN_GLOBAL_VRF_ALLOWED = 430,
    OF_OXM_BSN_GLOBAL_VRF_ALLOWED_MASKED = 431,
    OF_OXM_BSN_IN_PORTS_128 = 432,
    OF_OXM_BSN_IN_PORTS_128_MASKED = 433,
    OF_OXM_BSN_L3_DST_CLASS_ID = 434,
    OF_OXM_BSN_L3_DST_CLASS_ID_MASKED = 435,
    OF_OXM_BSN_L3_INTERFACE_CLASS_ID = 436,
    OF_OXM_BSN_L3_INTERFACE_CLASS_ID_MASKED = 437,
    OF_OXM_BSN_L3_SRC_CLASS_ID = 438,
    OF_OXM_BSN_L3_SRC_CLASS_ID_MASKED = 439,
    OF_OXM_BSN_LAG_ID = 440,
    OF_OXM_BSN_LAG_ID_MASKED = 441,
    OF_OXM_BSN_UDF0 = 442,
    OF_OXM_BSN_UDF0_MASKED = 443,
    OF_OXM_BSN_UDF1 = 444,
    OF_OXM_BSN_UDF1_MASKED = 445,
    OF_OXM_BSN_UDF2 = 446,
    OF_OXM_BSN_UDF2_MASKED = 447,
    OF_OXM_BSN_UDF3 = 448,
    OF_OXM_BSN_UDF3_MASKED = 449,
    OF_OXM_BSN_UDF4 = 450,
    OF_OXM_BSN_UDF4_MASKED = 451,
    OF_OXM_BSN_UDF5 = 452,
    OF_OXM_BSN_UDF5_MASKED = 453,
    OF_OXM_BSN_UDF6 = 454,
    OF_OXM_BSN_UDF6_MASKED = 455,
    OF_OXM_BSN_UDF7 = 456,
    OF_OXM_BSN_UDF7_MASKED = 457,
    OF_OXM_BSN_VRF = 458,
    OF_OXM_BSN_VRF_MASKED = 459,
    OF_OXM_ETH_DST = 460,
    OF_OXM_ETH_DST_MASKED = 461,
    OF_OXM_ETH_SRC = 462,
    OF_OXM_ETH_SRC_MASKED = 463,
    OF_OXM_ETH_TYPE = 464,
    OF_OXM_ETH_TYPE_MASKED = 465,
    OF_OXM_HEADER = 466,
    OF_OXM_ICMPV4_CODE = 467,
    OF_OXM_ICMPV4_CODE_MASKED = 468,
    OF_OXM_ICMPV4_TYPE = 469,
    OF_OXM_ICMPV4_TYPE_MASKED = 470,
    OF_OXM_ICMPV6_CODE = 471,
    OF_OXM_ICMPV6_CODE_MASKED = 472,
    OF_OXM_ICMPV6_TYPE = 473,
    OF_OXM_ICMPV6_TYPE_MASKED = 474,
    OF_OXM_IN_PHY_PORT = 475,
    OF_OXM_IN_PHY_PORT_MASKED = 476,
    OF_OXM_IN_PORT = 477,
    OF_OXM_IN_PORT_MASKED = 478,
    OF_OXM_IP_DSCP = 479,
    OF_OXM_IP_DSCP_MASKED = 480,
    OF_OXM_IP_ECN = 481,
    OF_OXM_IP_ECN_MASKED = 482,
    OF_OXM_IP_PROTO = 483,
    OF_OXM_IP_PROTO_MASKED = 484,
    OF_OXM_IPV4_DST = 485,
    OF_OXM_IPV4_DST_MASKED = 486,
    OF_OXM_IPV4_SRC = 487,
    OF_OXM_IPV4_SRC_MASKED = 488,
    OF_OXM_IPV6_DST = 489,
    OF_OXM_IPV6_DST_MASKED = 490,
    OF_OXM_IPV6_FLABEL = 491,
    OF_OXM_IPV6_FLABEL_MASKED = 492,
    OF_OXM_IPV6_ND_SLL = 493,
    OF_OXM_IPV6_ND_SLL_MASKED = 494,
    OF_OXM_IPV6_ND_TARGET = 495,
    OF_OXM_IPV6_ND_TARGET_MASKED = 496,
    OF_OXM_IPV6_ND_TLL = 497,
    OF_OXM_IPV6_ND_TLL_MASKED = 498,
    OF_OXM_IPV6_SRC = 499,
    OF_OXM_IPV6_SRC_MASKED = 500,
    OF_OXM_METADATA = 501,
    OF_OXM_METADATA_MASKED = 502,
    OF_OXM_MPLS_BOS = 503,
    OF_OXM_MPLS_BOS_MASKED = 504,
    OF_OXM_MPLS_LABEL = 505,
    OF_OXM_MPLS_LABEL_MASKED = 506,
    OF_OXM_MPLS_TC = 507,
    OF_OXM_MPLS_TC_MASKED = 508,
    OF_OXM_OFDPA_ALLOW_VLAN_TRANSLATION = 509,
    OF_OXM_OFDPA_COLOR = 510,
    OF_OXM_OFDPA_COLOR_ACTIONS_INDEX = 511,
    OF_OXM_OFDPA_DEI = 512,
    OF_OXM_OFDPA_L3_IN_PORT = 513,
    OF_OXM_OFDPA_LMEP_ID = 514,
    OF_OXM_OFDPA_MPLS_ACH_CHANNEL = 515,
    OF_OXM_OFDPA_MPLS_DATA_FIRST_NIBBLE = 516,
    OF_OXM_OFDPA_MPLS_L2_PORT = 517,
    OF_OXM_OFDPA_MPLS_L2_PORT_MASKED = 518,
    OF_OXM_OFDPA_MPLS_NEXT_LABEL_IS_GAL = 519,
    OF_OXM_OFDPA_MPLS_TTL = 520,
    OF_OXM_OFDPA_MPLS_TYPE = 521,
    OF_OXM_OFDPA_OAM_Y1731_MDL = 522,
    OF_OXM_OFDPA_OAM_Y1731_OPCODE = 523,
    OF_OXM_OFDPA_OVID = 524,
    OF_OXM_OFDPA_PROTECTION_INDEX = 525,
    OF_OXM_OFDPA_QOS_INDEX = 526,
    OF_OXM_OFDPA_RX_TIMESTAMP = 527,
    OF_OXM_OFDPA_RXFCL = 528,
    OF_OXM_OFDPA_TRAFFIC_CLASS = 529,
    OF_OXM_OFDPA_TXFCL = 530,
    OF_OXM_OFDPA_VRF = 531,
    OF_OXM_ONF_ACTSET_OUTPUT = 532,
    OF_OXM_SCTP_DST = 533,
    OF_OXM_SCTP_DST_MASKED = 534,
    OF_OXM_SCTP_SRC = 535,
    OF_OXM_SCTP_SRC_MASKED = 536,
    OF_OXM_TCP_DST = 537,
    OF_OXM_TCP_DST_MASKED = 538,
    OF_OXM_TCP_SRC = 539,
    OF_OXM_TCP_SRC_MASKED = 540,
    OF_OXM_TUNNEL_ID = 541,
    OF_OXM_TUNNEL_ID_MASKED = 542,
    OF_OXM_UDP_DST = 543,
    OF_OXM_UDP_DST_MASKED = 544,
    OF_OXM_UDP_SRC = 545,
    OF_OXM_UDP_SRC_MASKED = 546,
    OF_OXM_VLAN_PCP = 547,
    OF_OXM_VLAN_PCP_MASKED = 548,
    OF_OXM_VLAN_VID = 549,
    OF_OXM_VLAN_VID_MASKED = 550,
    OF_PACKET_QUEUE = 551,
    OF_PORT_DESC = 552,
    OF_PORT_STATS_ENTRY = 553,
    OF_QUEUE_PROP = 554,
    OF_QUEUE_PROP_EXPERIMENTER = 555,
    OF_QUEUE_PROP_HEADER = 556,
    OF_QUEUE_PROP_MAX_RATE = 557,
    OF_QUEUE_PROP_MIN_RATE = 558,
    OF_QUEUE_STATS_ENTRY = 559,
    OF_TABLE_FEATURE_PROP = 560,
    OF_TABLE_FEATURE_PROP_APPLY_ACTIONS = 561,
    OF_TABLE_FEATURE_PROP_APPLY_ACTIONS_MISS = 562,
    OF_TABLE_FEATURE_PROP_APPLY_SETFIELD = 563,
    OF_TABLE_FEATURE_PROP_APPLY_SETFIELD_MISS = 564,
    OF_TABLE_FEATURE_PROP_EXPERIMENTER = 565,
    OF_TABLE_FEATURE_PROP_EXPERIMENTER_MISS = 566,
    OF_TABLE_FEATURE_PROP_HEADER = 567,
    OF_TABLE_FEATURE_PROP_INSTRUCTIONS = 568,
    OF_TABLE_FEATURE_PROP_INSTRUCTIONS_MISS = 569,
    OF_TABLE_FEATURE_PROP_MATCH = 570,
    OF_TABLE_FEATURE_PROP_NEXT_TABLES = 571,
    OF_TABLE_FEATURE_PROP_NEXT_TABLES_MISS = 572,
    OF_TABLE_FEATURE_PROP_WILDCARDS = 573,
    OF_TABLE_FEATURE_PROP_WRITE_ACTIONS = 574,
    OF_TABLE_FEATURE_PROP_WRITE_ACTIONS_MISS = 575,
    OF_TABLE_FEATURE_PROP_WRITE_SETFIELD = 576,
    OF_TABLE_FEATURE_PROP_WRITE_SETFIELD_MISS = 577,
    OF_TABLE_FEATURES = 578,
    OF_TABLE_STATS_ENTRY = 579,
    OF_UINT32 = 580,
    OF_UINT64 = 581,
    OF_UINT8 = 582,
    OFP_QUEUE_DESC = 583,
    ONF_OXM_PACKET_REGS0 = 584,
    ONF_OXM_PACKET_REGS1 = 585,
    ONF_OXM_PACKET_REGS2 = 586,
    ONF_OXM_PACKET_REGS3 = 587,

    /* List objects */
    OF_LIST_ACTION = 588,
    OF_LIST_ACTION_ID = 589,
    OF_LIST_BSN_CONTROLLER_CONNECTION = 590,
    OF_LIST_BSN_DEBUG_COUNTER_DESC_STATS_ENTRY = 591,
    OF_LIST_BSN_DEBUG_COUNTER_STATS_ENTRY = 592,
    OF_LIST_BSN_FLOW_CHECKSUM_BUCKET_STATS_ENTRY = 593,
    OF_LIST_BSN_GENTABLE_BUCKET_STATS_ENTRY = 594,
    OF_LIST_BSN_GENTABLE_DESC_STATS_ENTRY = 595,
    OF_LIST_BSN_GENTABLE_ENTRY_DESC_STATS_ENTRY = 596,
    OF_LIST_BSN_GENTABLE_ENTRY_STATS_ENTRY = 597,
    OF_LIST_BSN_GENTABLE_STATS_ENTRY = 598,
    OF_LIST_BSN_INTERFACE = 599,
    OF_LIST_BSN_LACP_STATS_ENTRY = 600,
    OF_LIST_BSN_PORT_COUNTER_STATS_ENTRY = 601,
    OF_LIST_BSN_SWITCH_PIPELINE_STATS_ENTRY = 602,
    OF_LIST_BSN_TABLE_CHECKSUM_STATS_ENTRY = 603,
    OF_LIST_BSN_TLV = 604,
    OF_LIST_BSN_VLAN_COUNTER_STATS_ENTRY = 605,
    OF_LIST_BUCKET = 606,
    OF_LIST_BUCKET_COUNTER = 607,
    OF_LIST_FLOW_STATS_ENTRY = 608,
    OF_LIST_GROUP_DESC_STATS_ENTRY = 609,
    OF_LIST_GROUP_STATS_ENTRY = 610,
    OF_LIST_HELLO_ELEM = 611,
    OF_LIST_INSTRUCTION = 612,
    OF_LIST_INSTRUCTION_ID = 613,
    OF_LIST_METER_BAND = 614,
    OF_LIST_METER_BAND_STATS = 615,
    OF_LIST_METER_STATS = 616,
    OF_LIST_OXM = 617,
    OF_LIST_PACKET_QUEUE = 618,
    OF_LIST_PORT_DESC = 619,
    OF_LIST_PORT_STATS_ENTRY = 620,
    OF_LIST_QUEUE_PROP = 621,
    OF_LIST_QUEUE_STATS_ENTRY = 622,
    OF_LIST_TABLE_FEATURE_PROP = 623,
    OF_LIST_TABLE_FEATURES = 624,
    OF_LIST_TABLE_STATS_ENTRY = 625,
    OF_LIST_UINT32 = 626,
    OF_LIST_UINT64 = 627,
    OF_LIST_UINT8 = 628,

    

    /* Generic stats request/reply types; pseudo objects */

    OF_OBJECT_COUNT = 629
} of_object_id_t;

extern const char *const of_object_id_str[];

#define OF_MESSAGE_OBJECT_COUNT 212

/*
 * Macros to check if an object ID is within an inheritance class range
 */

#define OF_QUEUE_PROP_FIRST_ID      (OF_QUEUE_PROP + 1)
#define OF_QUEUE_PROP_LAST_ID       OF_QUEUE_PROP_MIN_RATE
#define OF_QUEUE_PROP_VALID_ID(id) \
    ((id) >= OF_QUEUE_PROP_FIRST_ID && \
     (id) <= OF_QUEUE_PROP_LAST_ID)

#define OF_ACTION_FIRST_ID      (OF_ACTION + 1)
#define OF_ACTION_LAST_ID       OF_ACTION_STRIP_VLAN
#define OF_ACTION_VALID_ID(id) \
    ((id) >= OF_ACTION_FIRST_ID && \
     (id) <= OF_ACTION_LAST_ID)

#define OF_INSTRUCTION_FIRST_ID      (OF_INSTRUCTION + 1)
#define OF_INSTRUCTION_LAST_ID       OF_INSTRUCTION_WRITE_METADATA
#define OF_INSTRUCTION_VALID_ID(id) \
    ((id) >= OF_INSTRUCTION_FIRST_ID && \
     (id) <= OF_INSTRUCTION_LAST_ID)

#define OF_TABLE_FEATURE_PROP_FIRST_ID      (OF_TABLE_FEATURE_PROP + 1)
#define OF_TABLE_FEATURE_PROP_LAST_ID       OF_TABLE_FEATURE_PROP_WRITE_SETFIELD_MISS
#define OF_TABLE_FEATURE_PROP_VALID_ID(id) \
    ((id) >= OF_TABLE_FEATURE_PROP_FIRST_ID && \
     (id) <= OF_TABLE_FEATURE_PROP_LAST_ID)

#define OF_OXM_FIRST_ID      (OF_OXM + 1)
#define OF_OXM_LAST_ID       OF_OXM_VLAN_VID_MASKED
#define OF_OXM_VALID_ID(id) \
    (((id) >= OF_OXM_FIRST_ID && (id) <= OF_OXM_LAST_ID) \
     || ((id) >= ONF_OXM_PACKET_REGS0 && (id) <= ONF_OXM_PACKET_REGS3))

/**
 * Function to check a wire ID
 * @param object_id The ID to check
 * @param base_object_id The inheritance parent, if applicable
 * @returns boolean: If base_object_id is an inheritance class, check if
 * object_id is valid as a subclass.  Otherwise return 1.
 *
 * Note: Could check that object_id == base_object_id in the
 * second case.
 */
static inline int
of_wire_id_valid(int object_id, int base_object_id) {
    switch (base_object_id) {
    case OF_ACTION:
        return OF_ACTION_VALID_ID(object_id);
    case OF_OXM:
        return OF_OXM_VALID_ID(object_id);
    case OF_QUEUE_PROP:
        return OF_QUEUE_PROP_VALID_ID(object_id);
    case OF_TABLE_FEATURE_PROP:
        return OF_TABLE_FEATURE_PROP_VALID_ID(object_id);
    case OF_INSTRUCTION:
        return OF_INSTRUCTION_VALID_ID(object_id);
    default:
        break;
    }
    return 1;
}

/****************************************************************
 *
 * Experimenter IDs
 *
 ****************************************************************/

#define OF_EXPERIMENTER_ID_OPENFLOW 0x000026e1
#define OF_EXPERIMENTER_ID_OFDPA 0x00001018
#define OF_EXPERIMENTER_ID_NICIRA 0x00002320
#define OF_EXPERIMENTER_ID_ONF 0x4f4e4600
#define OF_EXPERIMENTER_ID_BSN 0x005c16c7

/****************************************************************
 *
 * OpenFlow Match version specific and generic defines
 *
 ****************************************************************/

/**
 * Definitions to coerce v4 match (version 1.3) to v3 matches
 * (version 1.2).
 * @FIXME This is a stopgap and needs to get cleaned up.
 */
#define of_match_v4_t of_match_v3_t
#define of_match_v4_init of_match_v3_init
#define of_match_v4_new of_match_v3_new
#define of_match_v4_to_match of_match_v3_to_match
#define of_match_to_wire_match_v4 of_match_to_wire_match_v3
#define of_match_v4_delete of_match_v3_delete


/**
 * Definitions for wildcard macros for OF_VERSION_1_0
 */


#define OF_MATCH_V1_WC_ETH_DST_SHIFT 3
#define OF_MATCH_V1_WC_ETH_DST_MASK (1 << 3)
#define OF_MATCH_V1_WC_ETH_DST_SET(wc) ((wc) |= (1 << 3))
#define OF_MATCH_V1_WC_ETH_DST_CLEAR(wc) ((wc) &= ~(1 << 3))
#define OF_MATCH_V1_WC_ETH_DST_TEST(wc) ((wc) & (1 << 3))

#define OF_MATCH_V1_WC_ETH_SRC_SHIFT 2
#define OF_MATCH_V1_WC_ETH_SRC_MASK (1 << 2)
#define OF_MATCH_V1_WC_ETH_SRC_SET(wc) ((wc) |= (1 << 2))
#define OF_MATCH_V1_WC_ETH_SRC_CLEAR(wc) ((wc) &= ~(1 << 2))
#define OF_MATCH_V1_WC_ETH_SRC_TEST(wc) ((wc) & (1 << 2))

#define OF_MATCH_V1_WC_ETH_TYPE_SHIFT 4
#define OF_MATCH_V1_WC_ETH_TYPE_MASK (1 << 4)
#define OF_MATCH_V1_WC_ETH_TYPE_SET(wc) ((wc) |= (1 << 4))
#define OF_MATCH_V1_WC_ETH_TYPE_CLEAR(wc) ((wc) &= ~(1 << 4))
#define OF_MATCH_V1_WC_ETH_TYPE_TEST(wc) ((wc) & (1 << 4))

#define OF_MATCH_V1_WC_IN_PORT_SHIFT 0
#define OF_MATCH_V1_WC_IN_PORT_MASK (1 << 0)
#define OF_MATCH_V1_WC_IN_PORT_SET(wc) ((wc) |= (1 << 0))
#define OF_MATCH_V1_WC_IN_PORT_CLEAR(wc) ((wc) &= ~(1 << 0))
#define OF_MATCH_V1_WC_IN_PORT_TEST(wc) ((wc) & (1 << 0))

#define OF_MATCH_V1_WC_IPV4_DST_SHIFT 14
#define OF_MATCH_V1_WC_IPV4_DST_MASK (0x3f << 14)
#define OF_MATCH_V1_WC_IPV4_DST_CLEAR(wc) ((wc) &= ~(0x3f << 14))
#define OF_MATCH_V1_WC_IPV4_DST_SET(wc, value) do {   \
        OF_MATCH_V1_WC_IPV4_DST_CLEAR(wc); \
        ((wc) |= (((value) & 0x3f) << 14)); \
    } while (0)
#define OF_MATCH_V1_WC_IPV4_DST_TEST(wc) ((wc) & (0x3f << 14))
#define OF_MATCH_V1_WC_IPV4_DST_GET(wc) (((wc) >> 14) & 0x3f)

#define OF_MATCH_V1_WC_IP_PROTO_SHIFT 5
#define OF_MATCH_V1_WC_IP_PROTO_MASK (1 << 5)
#define OF_MATCH_V1_WC_IP_PROTO_SET(wc) ((wc) |= (1 << 5))
#define OF_MATCH_V1_WC_IP_PROTO_CLEAR(wc) ((wc) &= ~(1 << 5))
#define OF_MATCH_V1_WC_IP_PROTO_TEST(wc) ((wc) & (1 << 5))

#define OF_MATCH_V1_WC_IPV4_SRC_SHIFT 8
#define OF_MATCH_V1_WC_IPV4_SRC_MASK (0x3f << 8)
#define OF_MATCH_V1_WC_IPV4_SRC_CLEAR(wc) ((wc) &= ~(0x3f << 8))
#define OF_MATCH_V1_WC_IPV4_SRC_SET(wc, value) do {   \
        OF_MATCH_V1_WC_IPV4_SRC_CLEAR(wc); \
        ((wc) |= (((value) & 0x3f) << 8)); \
    } while (0)
#define OF_MATCH_V1_WC_IPV4_SRC_TEST(wc) ((wc) & (0x3f << 8))
#define OF_MATCH_V1_WC_IPV4_SRC_GET(wc) (((wc) >> 8) & 0x3f)

#define OF_MATCH_V1_WC_IP_DSCP_SHIFT 21
#define OF_MATCH_V1_WC_IP_DSCP_MASK (1 << 21)
#define OF_MATCH_V1_WC_IP_DSCP_SET(wc) ((wc) |= (1 << 21))
#define OF_MATCH_V1_WC_IP_DSCP_CLEAR(wc) ((wc) &= ~(1 << 21))
#define OF_MATCH_V1_WC_IP_DSCP_TEST(wc) ((wc) & (1 << 21))

#define OF_MATCH_V1_WC_TCP_DST_SHIFT 7
#define OF_MATCH_V1_WC_TCP_DST_MASK (1 << 7)
#define OF_MATCH_V1_WC_TCP_DST_SET(wc) ((wc) |= (1 << 7))
#define OF_MATCH_V1_WC_TCP_DST_CLEAR(wc) ((wc) &= ~(1 << 7))
#define OF_MATCH_V1_WC_TCP_DST_TEST(wc) ((wc) & (1 << 7))

#define OF_MATCH_V1_WC_TCP_SRC_SHIFT 6
#define OF_MATCH_V1_WC_TCP_SRC_MASK (1 << 6)
#define OF_MATCH_V1_WC_TCP_SRC_SET(wc) ((wc) |= (1 << 6))
#define OF_MATCH_V1_WC_TCP_SRC_CLEAR(wc) ((wc) &= ~(1 << 6))
#define OF_MATCH_V1_WC_TCP_SRC_TEST(wc) ((wc) & (1 << 6))

#define OF_MATCH_V1_WC_VLAN_PCP_SHIFT 20
#define OF_MATCH_V1_WC_VLAN_PCP_MASK (1 << 20)
#define OF_MATCH_V1_WC_VLAN_PCP_SET(wc) ((wc) |= (1 << 20))
#define OF_MATCH_V1_WC_VLAN_PCP_CLEAR(wc) ((wc) &= ~(1 << 20))
#define OF_MATCH_V1_WC_VLAN_PCP_TEST(wc) ((wc) & (1 << 20))

#define OF_MATCH_V1_WC_VLAN_VID_SHIFT 1
#define OF_MATCH_V1_WC_VLAN_VID_MASK (1 << 1)
#define OF_MATCH_V1_WC_VLAN_VID_SET(wc) ((wc) |= (1 << 1))
#define OF_MATCH_V1_WC_VLAN_VID_CLEAR(wc) ((wc) &= ~(1 << 1))
#define OF_MATCH_V1_WC_VLAN_VID_TEST(wc) ((wc) & (1 << 1))


/**
 * Definitions for wildcard macros for OF_VERSION_1_1
 */

#define OF_MATCH_V2_WC_ETH_TYPE_SHIFT 3
#define OF_MATCH_V2_WC_ETH_TYPE_MASK (1 << 3)
#define OF_MATCH_V2_WC_ETH_TYPE_SET(wc) ((wc) |= (1 << 3))
#define OF_MATCH_V2_WC_ETH_TYPE_CLEAR(wc) ((wc) &= ~(1 << 3))
#define OF_MATCH_V2_WC_ETH_TYPE_TEST(wc) ((wc) & (1 << 3))

#define OF_MATCH_V2_WC_IN_PORT_SHIFT 0
#define OF_MATCH_V2_WC_IN_PORT_MASK (1 << 0)
#define OF_MATCH_V2_WC_IN_PORT_SET(wc) ((wc) |= (1 << 0))
#define OF_MATCH_V2_WC_IN_PORT_CLEAR(wc) ((wc) &= ~(1 << 0))
#define OF_MATCH_V2_WC_IN_PORT_TEST(wc) ((wc) & (1 << 0))

#define OF_MATCH_V2_WC_IP_DSCP_SHIFT 4
#define OF_MATCH_V2_WC_IP_DSCP_MASK (1 << 4)
#define OF_MATCH_V2_WC_IP_DSCP_SET(wc) ((wc) |= (1 << 4))
#define OF_MATCH_V2_WC_IP_DSCP_CLEAR(wc) ((wc) &= ~(1 << 4))
#define OF_MATCH_V2_WC_IP_DSCP_TEST(wc) ((wc) & (1 << 4))

#define OF_MATCH_V2_WC_IP_PROTO_SHIFT 5
#define OF_MATCH_V2_WC_IP_PROTO_MASK (1 << 5)
#define OF_MATCH_V2_WC_IP_PROTO_SET(wc) ((wc) |= (1 << 5))
#define OF_MATCH_V2_WC_IP_PROTO_CLEAR(wc) ((wc) &= ~(1 << 5))
#define OF_MATCH_V2_WC_IP_PROTO_TEST(wc) ((wc) & (1 << 5))

#define OF_MATCH_V2_WC_MPLS_LABEL_SHIFT 8
#define OF_MATCH_V2_WC_MPLS_LABEL_MASK (1 << 8)
#define OF_MATCH_V2_WC_MPLS_LABEL_SET(wc) ((wc) |= (1 << 8))
#define OF_MATCH_V2_WC_MPLS_LABEL_CLEAR(wc) ((wc) &= ~(1 << 8))
#define OF_MATCH_V2_WC_MPLS_LABEL_TEST(wc) ((wc) & (1 << 8))

#define OF_MATCH_V2_WC_MPLS_TC_SHIFT 9
#define OF_MATCH_V2_WC_MPLS_TC_MASK (1 << 9)
#define OF_MATCH_V2_WC_MPLS_TC_SET(wc) ((wc) |= (1 << 9))
#define OF_MATCH_V2_WC_MPLS_TC_CLEAR(wc) ((wc) &= ~(1 << 9))
#define OF_MATCH_V2_WC_MPLS_TC_TEST(wc) ((wc) & (1 << 9))

#define OF_MATCH_V2_WC_TCP_DST_SHIFT 7
#define OF_MATCH_V2_WC_TCP_DST_MASK (1 << 7)
#define OF_MATCH_V2_WC_TCP_DST_SET(wc) ((wc) |= (1 << 7))
#define OF_MATCH_V2_WC_TCP_DST_CLEAR(wc) ((wc) &= ~(1 << 7))
#define OF_MATCH_V2_WC_TCP_DST_TEST(wc) ((wc) & (1 << 7))

#define OF_MATCH_V2_WC_TCP_SRC_SHIFT 6
#define OF_MATCH_V2_WC_TCP_SRC_MASK (1 << 6)
#define OF_MATCH_V2_WC_TCP_SRC_SET(wc) ((wc) |= (1 << 6))
#define OF_MATCH_V2_WC_TCP_SRC_CLEAR(wc) ((wc) &= ~(1 << 6))
#define OF_MATCH_V2_WC_TCP_SRC_TEST(wc) ((wc) & (1 << 6))

#define OF_MATCH_V2_WC_VLAN_PCP_SHIFT 2
#define OF_MATCH_V2_WC_VLAN_PCP_MASK (1 << 2)
#define OF_MATCH_V2_WC_VLAN_PCP_SET(wc) ((wc) |= (1 << 2))
#define OF_MATCH_V2_WC_VLAN_PCP_CLEAR(wc) ((wc) &= ~(1 << 2))
#define OF_MATCH_V2_WC_VLAN_PCP_TEST(wc) ((wc) & (1 << 2))

#define OF_MATCH_V2_WC_VLAN_VID_SHIFT 1
#define OF_MATCH_V2_WC_VLAN_VID_MASK (1 << 1)
#define OF_MATCH_V2_WC_VLAN_VID_SET(wc) ((wc) |= (1 << 1))
#define OF_MATCH_V2_WC_VLAN_VID_CLEAR(wc) ((wc) &= ~(1 << 1))
#define OF_MATCH_V2_WC_VLAN_VID_TEST(wc) ((wc) & (1 << 1))


/* These are from the OpenFlow 1.2 header file */

/* OXM index values for bitmaps and parsing */
enum of_oxm_index_e {
    OF_OXM_INDEX_IN_PORT        = 0,  /* Switch input port. */
    OF_OXM_INDEX_IN_PHY_PORT    = 1,  /* Switch physical input port. */
    OF_OXM_INDEX_METADATA       = 2,  /* Metadata passed between tables. */
    OF_OXM_INDEX_ETH_DST        = 3,  /* Ethernet destination address. */
    OF_OXM_INDEX_ETH_SRC        = 4,  /* Ethernet source address. */
    OF_OXM_INDEX_ETH_TYPE       = 5,  /* Ethernet frame type. */
    OF_OXM_INDEX_VLAN_VID       = 6,  /* VLAN id. */
    OF_OXM_INDEX_VLAN_PCP       = 7,  /* VLAN priority. */
    OF_OXM_INDEX_IP_DSCP        = 8,  /* IP DSCP (6 bits in ToS field). */
    OF_OXM_INDEX_IP_ECN         = 9,  /* IP ECN (2 bits in ToS field). */
    OF_OXM_INDEX_IP_PROTO       = 10, /* IP protocol. */
    OF_OXM_INDEX_IPV4_SRC       = 11, /* IPv4 source address. */
    OF_OXM_INDEX_IPV4_DST       = 12, /* IPv4 destination address. */
    OF_OXM_INDEX_TCP_SRC        = 13, /* TCP source port. */
    OF_OXM_INDEX_TCP_DST        = 14, /* TCP destination port. */
    OF_OXM_INDEX_UDP_SRC        = 15, /* UDP source port. */
    OF_OXM_INDEX_UDP_DST        = 16, /* UDP destination port. */
    OF_OXM_INDEX_SCTP_SRC       = 17, /* SCTP source port. */
    OF_OXM_INDEX_SCTP_DST       = 18, /* SCTP destination port. */
    OF_OXM_INDEX_ICMPV4_TYPE    = 19, /* ICMP type. */
    OF_OXM_INDEX_ICMPV4_CODE    = 20, /* ICMP code. */
    OF_OXM_INDEX_ARP_OP         = 21, /* ARP opcode. */
    OF_OXM_INDEX_ARP_SPA        = 22, /* ARP source IPv4 address. */
    OF_OXM_INDEX_ARP_TPA        = 23, /* ARP target IPv4 address. */
    OF_OXM_INDEX_ARP_SHA        = 24, /* ARP source hardware address. */
    OF_OXM_INDEX_ARP_THA        = 25, /* ARP target hardware address. */
    OF_OXM_INDEX_IPV6_SRC       = 26, /* IPv6 source address. */
    OF_OXM_INDEX_IPV6_DST       = 27, /* IPv6 destination address. */
    OF_OXM_INDEX_IPV6_FLABEL    = 28, /* IPv6 Flow Label */
    OF_OXM_INDEX_ICMPV6_TYPE    = 29, /* ICMPv6 type. */
    OF_OXM_INDEX_ICMPV6_CODE    = 30, /* ICMPv6 code. */
    OF_OXM_INDEX_IPV6_ND_TARGET = 31, /* Target address for ND. */
    OF_OXM_INDEX_IPV6_ND_SLL    = 32, /* Source link-layer for ND. */
    OF_OXM_INDEX_IPV6_ND_TLL    = 33, /* Target link-layer for ND. */
    OF_OXM_INDEX_MPLS_LABEL     = 34, /* MPLS label. */
    OF_OXM_INDEX_MPLS_TC        = 35, /* MPLS TC. */

    OF_OXM_INDEX_BSN_IN_PORTS_128 = 36,
    OF_OXM_INDEX_BSN_LAG_ID = 37,
    OF_OXM_INDEX_BSN_VRF = 38,
    OF_OXM_INDEX_BSN_GLOBAL_VRF_ALLOWED = 39,
    OF_OXM_INDEX_BSN_L3_INTERFACE_CLASS_ID = 40,
    OF_OXM_INDEX_BSN_L3_SRC_CLASS_ID = 41,
    OF_OXM_INDEX_BSN_L3_DST_CLASS_ID = 42,
    OF_OXM_INDEX_BSN_EGR_PORT_GROUP_ID = 43,
    OF_OXM_INDEX_BSN_UDF0 = 44,
    OF_OXM_INDEX_BSN_UDF1 = 45,
    OF_OXM_INDEX_BSN_UDF2 = 46,
    OF_OXM_INDEX_BSN_UDF3 = 47,
    OF_OXM_INDEX_BSN_UDF4 = 48,
    OF_OXM_INDEX_BSN_UDF5 = 49,
    OF_OXM_INDEX_BSN_UDF6 = 50,
    OF_OXM_INDEX_BSN_UDF7 = 51,

#ifdef OFDPA_FIXUP

    OF_OXM_INDEX_MPLS_BOS                     = 36,
    OF_OXM_INDEX_TUNNEL_ID                    = 37,

    OF_OXM_INDEX_OFDPA_VRF                    = 38, /* OF-DPA */
    OF_OXM_INDEX_OFDPA_TRAFFIC_CLASS          = 39, /* OF-DPA */
    OF_OXM_INDEX_OFDPA_COLOR                  = 40, /* OF-DPA */
    OF_OXM_INDEX_OFDPA_DEI                    = 41, /* OF-DPA */
    OF_OXM_INDEX_OFDPA_QOS_INDEX              = 42, /* OF-DPA */
    OF_OXM_INDEX_OFDPA_LMEP_ID                = 43, /* OF-DPA */
    OF_OXM_INDEX_OFDPA_MPLS_TTL               = 44, /* OF-DPA */
    OF_OXM_INDEX_OFDPA_MPLS_L2_PORT           = 45, /* OF-DPA */
    OF_OXM_INDEX_OFDPA_L3_IN_PORT             = 46, /* OF-DPA */
    OF_OXM_INDEX_OFDPA_OVID                   = 47, /* OF-DPA */
    OF_OXM_INDEX_OFDPA_MPLS_DATA_FIRST_NIBBLE = 48, /* OF-DPA */
    OF_OXM_INDEX_OFDPA_MPLS_ACH_CHANNEL       = 49, /* OF-DPA */
    OF_OXM_INDEX_OFDPA_MPLS_NEXT_LABEL_IS_GAL = 50, /* OF-DPA */
    OF_OXM_INDEX_OFDPA_OAM_Y1731_MDL          = 51, /* OF-DPA */
    OF_OXM_INDEX_OFDPA_OAM_Y1731_OPCODE       = 52, /* OF-DPA */
    OF_OXM_INDEX_OFDPA_COLOR_ACTIONS_INDEX    = 53, /* OF-DPA */
    OF_OXM_INDEX_OFDPA_TXFCL                  = 54, /* OF-DPA */
    OF_OXM_INDEX_OFDPA_RXFCL                  = 55, /* OF-DPA */
    OF_OXM_INDEX_OFDPA_RX_TIMESTAMP           = 56, /* OF-DPA */
    OF_OXM_INDEX_OFDPA_BFD_DISCRIMINATOR      = 57, /* OF-DPA */
    OF_OXM_INDEX_OFDPA_PROTECTION_INDEX       = 58, /* OF-DPA */
    OF_OXM_INDEX_OFDPA_ALLOW_VLAN_TRANSLATION = 59, /* OF-DPA */
    OF_OXM_INDEX_OFDPA_MPLS_TYPE              = 61, /* OF-DPA */

    OF_OXM_INDEX_ONF_ACTSET_OUTPUT            = 62, /* ONF */
#endif /* OFDPA_FIXUP */
};

#define OF_OXM_BIT(index) (((uint64_t) 1) << (index))

/*
 * The generic match structure uses the OXM bit indices for it's
 * bitmasks for active and masked values
 */

/* Mask/value check/set macros for ofdpa_mpls_ttl */

/**
 * Set the mask for an exact match of ofdpa_mpls_ttl
 */
#define OF_MATCH_MASK_OFDPA_MPLS_TTL_EXACT_SET(_match)   \
    MEMSET(&(_match)->masks.ofdpa_mpls_ttl, 0xff, \
        sizeof(((_match)->masks).ofdpa_mpls_ttl))

/**
 * Clear the mask for ofdpa_mpls_ttl making that field inactive for the match
 */
#define OF_MATCH_MASK_OFDPA_MPLS_TTL_CLEAR(_match) \
    MEMSET(&(_match)->masks.ofdpa_mpls_ttl, 0, \
        sizeof(((_match)->masks).ofdpa_mpls_ttl))

/**
 * Test whether the match is exact for ofdpa_mpls_ttl
 */
#define OF_MATCH_MASK_OFDPA_MPLS_TTL_EXACT_TEST(_match) \
    OF_VARIABLE_IS_ALL_ONES(&(((_match)->masks).ofdpa_mpls_ttl))

/**
 * Test whether key ofdpa_mpls_ttl is being checked in the match
 */
#define OF_MATCH_MASK_OFDPA_MPLS_TTL_ACTIVE_TEST(_match) \
    OF_VARIABLE_IS_NON_ZERO(&(((_match)->masks).ofdpa_mpls_ttl))


/* Mask/value check/set macros for ofdpa_mpls_next_label_is_gal */

/**
 * Set the mask for an exact match of ofdpa_mpls_next_label_is_gal
 */
#define OF_MATCH_MASK_OFDPA_MPLS_NEXT_LABEL_IS_GAL_EXACT_SET(_match)   \
    MEMSET(&(_match)->masks.ofdpa_mpls_next_label_is_gal, 0xff, \
        sizeof(((_match)->masks).ofdpa_mpls_next_label_is_gal))

/**
 * Clear the mask for ofdpa_mpls_next_label_is_gal making that field inactive for the match
 */
#define OF_MATCH_MASK_OFDPA_MPLS_NEXT_LABEL_IS_GAL_CLEAR(_match) \
    MEMSET(&(_match)->masks.ofdpa_mpls_next_label_is_gal, 0, \
        sizeof(((_match)->masks).ofdpa_mpls_next_label_is_gal))

/**
 * Test whether the match is exact for ofdpa_mpls_next_label_is_gal
 */
#define OF_MATCH_MASK_OFDPA_MPLS_NEXT_LABEL_IS_GAL_EXACT_TEST(_match) \
    OF_VARIABLE_IS_ALL_ONES(&(((_match)->masks).ofdpa_mpls_next_label_is_gal))

/**
 * Test whether key ofdpa_mpls_next_label_is_gal is being checked in the match
 */
#define OF_MATCH_MASK_OFDPA_MPLS_NEXT_LABEL_IS_GAL_ACTIVE_TEST(_match) \
    OF_VARIABLE_IS_NON_ZERO(&(((_match)->masks).ofdpa_mpls_next_label_is_gal))


/* Mask/value check/set macros for bsn_lag_id */

/**
 * Set the mask for an exact match of bsn_lag_id
 */
#define OF_MATCH_MASK_BSN_LAG_ID_EXACT_SET(_match)   \
    MEMSET(&(_match)->masks.bsn_lag_id, 0xff, \
        sizeof(((_match)->masks).bsn_lag_id))

/**
 * Clear the mask for bsn_lag_id making that field inactive for the match
 */
#define OF_MATCH_MASK_BSN_LAG_ID_CLEAR(_match) \
    MEMSET(&(_match)->masks.bsn_lag_id, 0, \
        sizeof(((_match)->masks).bsn_lag_id))

/**
 * Test whether the match is exact for bsn_lag_id
 */
#define OF_MATCH_MASK_BSN_LAG_ID_EXACT_TEST(_match) \
    OF_VARIABLE_IS_ALL_ONES(&(((_match)->masks).bsn_lag_id))

/**
 * Test whether key bsn_lag_id is being checked in the match
 */
#define OF_MATCH_MASK_BSN_LAG_ID_ACTIVE_TEST(_match) \
    OF_VARIABLE_IS_NON_ZERO(&(((_match)->masks).bsn_lag_id))


/* Mask/value check/set macros for ofdpa_color_actions_index */

/**
 * Set the mask for an exact match of ofdpa_color_actions_index
 */
#define OF_MATCH_MASK_OFDPA_COLOR_ACTIONS_INDEX_EXACT_SET(_match)   \
    MEMSET(&(_match)->masks.ofdpa_color_actions_index, 0xff, \
        sizeof(((_match)->masks).ofdpa_color_actions_index))

/**
 * Clear the mask for ofdpa_color_actions_index making that field inactive for the match
 */
#define OF_MATCH_MASK_OFDPA_COLOR_ACTIONS_INDEX_CLEAR(_match) \
    MEMSET(&(_match)->masks.ofdpa_color_actions_index, 0, \
        sizeof(((_match)->masks).ofdpa_color_actions_index))

/**
 * Test whether the match is exact for ofdpa_color_actions_index
 */
#define OF_MATCH_MASK_OFDPA_COLOR_ACTIONS_INDEX_EXACT_TEST(_match) \
    OF_VARIABLE_IS_ALL_ONES(&(((_match)->masks).ofdpa_color_actions_index))

/**
 * Test whether key ofdpa_color_actions_index is being checked in the match
 */
#define OF_MATCH_MASK_OFDPA_COLOR_ACTIONS_INDEX_ACTIVE_TEST(_match) \
    OF_VARIABLE_IS_NON_ZERO(&(((_match)->masks).ofdpa_color_actions_index))


/* Mask/value check/set macros for vlan_pcp */

/**
 * Set the mask for an exact match of vlan_pcp
 */
#define OF_MATCH_MASK_VLAN_PCP_EXACT_SET(_match)   \
    MEMSET(&(_match)->masks.vlan_pcp, 0xff, \
        sizeof(((_match)->masks).vlan_pcp))

/**
 * Clear the mask for vlan_pcp making that field inactive for the match
 */
#define OF_MATCH_MASK_VLAN_PCP_CLEAR(_match) \
    MEMSET(&(_match)->masks.vlan_pcp, 0, \
        sizeof(((_match)->masks).vlan_pcp))

/**
 * Test whether the match is exact for vlan_pcp
 */
#define OF_MATCH_MASK_VLAN_PCP_EXACT_TEST(_match) \
    OF_VARIABLE_IS_ALL_ONES(&(((_match)->masks).vlan_pcp))

/**
 * Test whether key vlan_pcp is being checked in the match
 */
#define OF_MATCH_MASK_VLAN_PCP_ACTIVE_TEST(_match) \
    OF_VARIABLE_IS_NON_ZERO(&(((_match)->masks).vlan_pcp))


/* Mask/value check/set macros for ipv4_src */

/**
 * Set the mask for an exact match of ipv4_src
 */
#define OF_MATCH_MASK_IPV4_SRC_EXACT_SET(_match)   \
    MEMSET(&(_match)->masks.ipv4_src, 0xff, \
        sizeof(((_match)->masks).ipv4_src))

/**
 * Clear the mask for ipv4_src making that field inactive for the match
 */
#define OF_MATCH_MASK_IPV4_SRC_CLEAR(_match) \
    MEMSET(&(_match)->masks.ipv4_src, 0, \
        sizeof(((_match)->masks).ipv4_src))

/**
 * Test whether the match is exact for ipv4_src
 */
#define OF_MATCH_MASK_IPV4_SRC_EXACT_TEST(_match) \
    OF_VARIABLE_IS_ALL_ONES(&(((_match)->masks).ipv4_src))

/**
 * Test whether key ipv4_src is being checked in the match
 */
#define OF_MATCH_MASK_IPV4_SRC_ACTIVE_TEST(_match) \
    OF_VARIABLE_IS_NON_ZERO(&(((_match)->masks).ipv4_src))


/* Mask/value check/set macros for ipv6_dst */

/**
 * Set the mask for an exact match of ipv6_dst
 */
#define OF_MATCH_MASK_IPV6_DST_EXACT_SET(_match)   \
    MEMSET(&(_match)->masks.ipv6_dst, 0xff, \
        sizeof(((_match)->masks).ipv6_dst))

/**
 * Clear the mask for ipv6_dst making that field inactive for the match
 */
#define OF_MATCH_MASK_IPV6_DST_CLEAR(_match) \
    MEMSET(&(_match)->masks.ipv6_dst, 0, \
        sizeof(((_match)->masks).ipv6_dst))

/**
 * Test whether the match is exact for ipv6_dst
 */
#define OF_MATCH_MASK_IPV6_DST_EXACT_TEST(_match) \
    OF_VARIABLE_IS_ALL_ONES(&(((_match)->masks).ipv6_dst))

/**
 * Test whether key ipv6_dst is being checked in the match
 */
#define OF_MATCH_MASK_IPV6_DST_ACTIVE_TEST(_match) \
    OF_VARIABLE_IS_NON_ZERO(&(((_match)->masks).ipv6_dst))


/* Mask/value check/set macros for arp_sha */

/**
 * Set the mask for an exact match of arp_sha
 */
#define OF_MATCH_MASK_ARP_SHA_EXACT_SET(_match)   \
    MEMSET(&(_match)->masks.arp_sha, 0xff, \
        sizeof(((_match)->masks).arp_sha))

/**
 * Clear the mask for arp_sha making that field inactive for the match
 */
#define OF_MATCH_MASK_ARP_SHA_CLEAR(_match) \
    MEMSET(&(_match)->masks.arp_sha, 0, \
        sizeof(((_match)->masks).arp_sha))

/**
 * Test whether the match is exact for arp_sha
 */
#define OF_MATCH_MASK_ARP_SHA_EXACT_TEST(_match) \
    OF_VARIABLE_IS_ALL_ONES(&(((_match)->masks).arp_sha))

/**
 * Test whether key arp_sha is being checked in the match
 */
#define OF_MATCH_MASK_ARP_SHA_ACTIVE_TEST(_match) \
    OF_VARIABLE_IS_NON_ZERO(&(((_match)->masks).arp_sha))


/* Mask/value check/set macros for ofdpa_qos_index */

/**
 * Set the mask for an exact match of ofdpa_qos_index
 */
#define OF_MATCH_MASK_OFDPA_QOS_INDEX_EXACT_SET(_match)   \
    MEMSET(&(_match)->masks.ofdpa_qos_index, 0xff, \
        sizeof(((_match)->masks).ofdpa_qos_index))

/**
 * Clear the mask for ofdpa_qos_index making that field inactive for the match
 */
#define OF_MATCH_MASK_OFDPA_QOS_INDEX_CLEAR(_match) \
    MEMSET(&(_match)->masks.ofdpa_qos_index, 0, \
        sizeof(((_match)->masks).ofdpa_qos_index))

/**
 * Test whether the match is exact for ofdpa_qos_index
 */
#define OF_MATCH_MASK_OFDPA_QOS_INDEX_EXACT_TEST(_match) \
    OF_VARIABLE_IS_ALL_ONES(&(((_match)->masks).ofdpa_qos_index))

/**
 * Test whether key ofdpa_qos_index is being checked in the match
 */
#define OF_MATCH_MASK_OFDPA_QOS_INDEX_ACTIVE_TEST(_match) \
    OF_VARIABLE_IS_NON_ZERO(&(((_match)->masks).ofdpa_qos_index))


/* Mask/value check/set macros for sctp_src */

/**
 * Set the mask for an exact match of sctp_src
 */
#define OF_MATCH_MASK_SCTP_SRC_EXACT_SET(_match)   \
    MEMSET(&(_match)->masks.sctp_src, 0xff, \
        sizeof(((_match)->masks).sctp_src))

/**
 * Clear the mask for sctp_src making that field inactive for the match
 */
#define OF_MATCH_MASK_SCTP_SRC_CLEAR(_match) \
    MEMSET(&(_match)->masks.sctp_src, 0, \
        sizeof(((_match)->masks).sctp_src))

/**
 * Test whether the match is exact for sctp_src
 */
#define OF_MATCH_MASK_SCTP_SRC_EXACT_TEST(_match) \
    OF_VARIABLE_IS_ALL_ONES(&(((_match)->masks).sctp_src))

/**
 * Test whether key sctp_src is being checked in the match
 */
#define OF_MATCH_MASK_SCTP_SRC_ACTIVE_TEST(_match) \
    OF_VARIABLE_IS_NON_ZERO(&(((_match)->masks).sctp_src))


/* Mask/value check/set macros for icmpv6_code */

/**
 * Set the mask for an exact match of icmpv6_code
 */
#define OF_MATCH_MASK_ICMPV6_CODE_EXACT_SET(_match)   \
    MEMSET(&(_match)->masks.icmpv6_code, 0xff, \
        sizeof(((_match)->masks).icmpv6_code))

/**
 * Clear the mask for icmpv6_code making that field inactive for the match
 */
#define OF_MATCH_MASK_ICMPV6_CODE_CLEAR(_match) \
    MEMSET(&(_match)->masks.icmpv6_code, 0, \
        sizeof(((_match)->masks).icmpv6_code))

/**
 * Test whether the match is exact for icmpv6_code
 */
#define OF_MATCH_MASK_ICMPV6_CODE_EXACT_TEST(_match) \
    OF_VARIABLE_IS_ALL_ONES(&(((_match)->masks).icmpv6_code))

/**
 * Test whether key icmpv6_code is being checked in the match
 */
#define OF_MATCH_MASK_ICMPV6_CODE_ACTIVE_TEST(_match) \
    OF_VARIABLE_IS_NON_ZERO(&(((_match)->masks).icmpv6_code))


/* Mask/value check/set macros for eth_dst */

/**
 * Set the mask for an exact match of eth_dst
 */
#define OF_MATCH_MASK_ETH_DST_EXACT_SET(_match)   \
    MEMSET(&(_match)->masks.eth_dst, 0xff, \
        sizeof(((_match)->masks).eth_dst))

/**
 * Clear the mask for eth_dst making that field inactive for the match
 */
#define OF_MATCH_MASK_ETH_DST_CLEAR(_match) \
    MEMSET(&(_match)->masks.eth_dst, 0, \
        sizeof(((_match)->masks).eth_dst))

/**
 * Test whether the match is exact for eth_dst
 */
#define OF_MATCH_MASK_ETH_DST_EXACT_TEST(_match) \
    OF_VARIABLE_IS_ALL_ONES(&(((_match)->masks).eth_dst))

/**
 * Test whether key eth_dst is being checked in the match
 */
#define OF_MATCH_MASK_ETH_DST_ACTIVE_TEST(_match) \
    OF_VARIABLE_IS_NON_ZERO(&(((_match)->masks).eth_dst))


/* Mask/value check/set macros for ofdpa_rxfcl */

/**
 * Set the mask for an exact match of ofdpa_rxfcl
 */
#define OF_MATCH_MASK_OFDPA_RXFCL_EXACT_SET(_match)   \
    MEMSET(&(_match)->masks.ofdpa_rxfcl, 0xff, \
        sizeof(((_match)->masks).ofdpa_rxfcl))

/**
 * Clear the mask for ofdpa_rxfcl making that field inactive for the match
 */
#define OF_MATCH_MASK_OFDPA_RXFCL_CLEAR(_match) \
    MEMSET(&(_match)->masks.ofdpa_rxfcl, 0, \
        sizeof(((_match)->masks).ofdpa_rxfcl))

/**
 * Test whether the match is exact for ofdpa_rxfcl
 */
#define OF_MATCH_MASK_OFDPA_RXFCL_EXACT_TEST(_match) \
    OF_VARIABLE_IS_ALL_ONES(&(((_match)->masks).ofdpa_rxfcl))

/**
 * Test whether key ofdpa_rxfcl is being checked in the match
 */
#define OF_MATCH_MASK_OFDPA_RXFCL_ACTIVE_TEST(_match) \
    OF_VARIABLE_IS_NON_ZERO(&(((_match)->masks).ofdpa_rxfcl))


/* Mask/value check/set macros for ipv4_dst */

/**
 * Set the mask for an exact match of ipv4_dst
 */
#define OF_MATCH_MASK_IPV4_DST_EXACT_SET(_match)   \
    MEMSET(&(_match)->masks.ipv4_dst, 0xff, \
        sizeof(((_match)->masks).ipv4_dst))

/**
 * Clear the mask for ipv4_dst making that field inactive for the match
 */
#define OF_MATCH_MASK_IPV4_DST_CLEAR(_match) \
    MEMSET(&(_match)->masks.ipv4_dst, 0, \
        sizeof(((_match)->masks).ipv4_dst))

/**
 * Test whether the match is exact for ipv4_dst
 */
#define OF_MATCH_MASK_IPV4_DST_EXACT_TEST(_match) \
    OF_VARIABLE_IS_ALL_ONES(&(((_match)->masks).ipv4_dst))

/**
 * Test whether key ipv4_dst is being checked in the match
 */
#define OF_MATCH_MASK_IPV4_DST_ACTIVE_TEST(_match) \
    OF_VARIABLE_IS_NON_ZERO(&(((_match)->masks).ipv4_dst))


/* Mask/value check/set macros for udp_src */

/**
 * Set the mask for an exact match of udp_src
 */
#define OF_MATCH_MASK_UDP_SRC_EXACT_SET(_match)   \
    MEMSET(&(_match)->masks.udp_src, 0xff, \
        sizeof(((_match)->masks).udp_src))

/**
 * Clear the mask for udp_src making that field inactive for the match
 */
#define OF_MATCH_MASK_UDP_SRC_CLEAR(_match) \
    MEMSET(&(_match)->masks.udp_src, 0, \
        sizeof(((_match)->masks).udp_src))

/**
 * Test whether the match is exact for udp_src
 */
#define OF_MATCH_MASK_UDP_SRC_EXACT_TEST(_match) \
    OF_VARIABLE_IS_ALL_ONES(&(((_match)->masks).udp_src))

/**
 * Test whether key udp_src is being checked in the match
 */
#define OF_MATCH_MASK_UDP_SRC_ACTIVE_TEST(_match) \
    OF_VARIABLE_IS_NON_ZERO(&(((_match)->masks).udp_src))


/* Mask/value check/set macros for tunnel_id */

/**
 * Set the mask for an exact match of tunnel_id
 */
#define OF_MATCH_MASK_TUNNEL_ID_EXACT_SET(_match)   \
    MEMSET(&(_match)->masks.tunnel_id, 0xff, \
        sizeof(((_match)->masks).tunnel_id))

/**
 * Clear the mask for tunnel_id making that field inactive for the match
 */
#define OF_MATCH_MASK_TUNNEL_ID_CLEAR(_match) \
    MEMSET(&(_match)->masks.tunnel_id, 0, \
        sizeof(((_match)->masks).tunnel_id))

/**
 * Test whether the match is exact for tunnel_id
 */
#define OF_MATCH_MASK_TUNNEL_ID_EXACT_TEST(_match) \
    OF_VARIABLE_IS_ALL_ONES(&(((_match)->masks).tunnel_id))

/**
 * Test whether key tunnel_id is being checked in the match
 */
#define OF_MATCH_MASK_TUNNEL_ID_ACTIVE_TEST(_match) \
    OF_VARIABLE_IS_NON_ZERO(&(((_match)->masks).tunnel_id))


/* Mask/value check/set macros for arp_op */

/**
 * Set the mask for an exact match of arp_op
 */
#define OF_MATCH_MASK_ARP_OP_EXACT_SET(_match)   \
    MEMSET(&(_match)->masks.arp_op, 0xff, \
        sizeof(((_match)->masks).arp_op))

/**
 * Clear the mask for arp_op making that field inactive for the match
 */
#define OF_MATCH_MASK_ARP_OP_CLEAR(_match) \
    MEMSET(&(_match)->masks.arp_op, 0, \
        sizeof(((_match)->masks).arp_op))

/**
 * Test whether the match is exact for arp_op
 */
#define OF_MATCH_MASK_ARP_OP_EXACT_TEST(_match) \
    OF_VARIABLE_IS_ALL_ONES(&(((_match)->masks).arp_op))

/**
 * Test whether key arp_op is being checked in the match
 */
#define OF_MATCH_MASK_ARP_OP_ACTIVE_TEST(_match) \
    OF_VARIABLE_IS_NON_ZERO(&(((_match)->masks).arp_op))


/* Mask/value check/set macros for eth_type */

/**
 * Set the mask for an exact match of eth_type
 */
#define OF_MATCH_MASK_ETH_TYPE_EXACT_SET(_match)   \
    MEMSET(&(_match)->masks.eth_type, 0xff, \
        sizeof(((_match)->masks).eth_type))

/**
 * Clear the mask for eth_type making that field inactive for the match
 */
#define OF_MATCH_MASK_ETH_TYPE_CLEAR(_match) \
    MEMSET(&(_match)->masks.eth_type, 0, \
        sizeof(((_match)->masks).eth_type))

/**
 * Test whether the match is exact for eth_type
 */
#define OF_MATCH_MASK_ETH_TYPE_EXACT_TEST(_match) \
    OF_VARIABLE_IS_ALL_ONES(&(((_match)->masks).eth_type))

/**
 * Test whether key eth_type is being checked in the match
 */
#define OF_MATCH_MASK_ETH_TYPE_ACTIVE_TEST(_match) \
    OF_VARIABLE_IS_NON_ZERO(&(((_match)->masks).eth_type))


/* Mask/value check/set macros for ofdpa_rx_timestamp */

/**
 * Set the mask for an exact match of ofdpa_rx_timestamp
 */
#define OF_MATCH_MASK_OFDPA_RX_TIMESTAMP_EXACT_SET(_match)   \
    MEMSET(&(_match)->masks.ofdpa_rx_timestamp, 0xff, \
        sizeof(((_match)->masks).ofdpa_rx_timestamp))

/**
 * Clear the mask for ofdpa_rx_timestamp making that field inactive for the match
 */
#define OF_MATCH_MASK_OFDPA_RX_TIMESTAMP_CLEAR(_match) \
    MEMSET(&(_match)->masks.ofdpa_rx_timestamp, 0, \
        sizeof(((_match)->masks).ofdpa_rx_timestamp))

/**
 * Test whether the match is exact for ofdpa_rx_timestamp
 */
#define OF_MATCH_MASK_OFDPA_RX_TIMESTAMP_EXACT_TEST(_match) \
    OF_VARIABLE_IS_ALL_ONES(&(((_match)->masks).ofdpa_rx_timestamp))

/**
 * Test whether key ofdpa_rx_timestamp is being checked in the match
 */
#define OF_MATCH_MASK_OFDPA_RX_TIMESTAMP_ACTIVE_TEST(_match) \
    OF_VARIABLE_IS_NON_ZERO(&(((_match)->masks).ofdpa_rx_timestamp))


/* Mask/value check/set macros for ofdpa_lmep_id */

/**
 * Set the mask for an exact match of ofdpa_lmep_id
 */
#define OF_MATCH_MASK_OFDPA_LMEP_ID_EXACT_SET(_match)   \
    MEMSET(&(_match)->masks.ofdpa_lmep_id, 0xff, \
        sizeof(((_match)->masks).ofdpa_lmep_id))

/**
 * Clear the mask for ofdpa_lmep_id making that field inactive for the match
 */
#define OF_MATCH_MASK_OFDPA_LMEP_ID_CLEAR(_match) \
    MEMSET(&(_match)->masks.ofdpa_lmep_id, 0, \
        sizeof(((_match)->masks).ofdpa_lmep_id))

/**
 * Test whether the match is exact for ofdpa_lmep_id
 */
#define OF_MATCH_MASK_OFDPA_LMEP_ID_EXACT_TEST(_match) \
    OF_VARIABLE_IS_ALL_ONES(&(((_match)->masks).ofdpa_lmep_id))

/**
 * Test whether key ofdpa_lmep_id is being checked in the match
 */
#define OF_MATCH_MASK_OFDPA_LMEP_ID_ACTIVE_TEST(_match) \
    OF_VARIABLE_IS_NON_ZERO(&(((_match)->masks).ofdpa_lmep_id))


/* Mask/value check/set macros for bsn_l3_interface_class_id */

/**
 * Set the mask for an exact match of bsn_l3_interface_class_id
 */
#define OF_MATCH_MASK_BSN_L3_INTERFACE_CLASS_ID_EXACT_SET(_match)   \
    MEMSET(&(_match)->masks.bsn_l3_interface_class_id, 0xff, \
        sizeof(((_match)->masks).bsn_l3_interface_class_id))

/**
 * Clear the mask for bsn_l3_interface_class_id making that field inactive for the match
 */
#define OF_MATCH_MASK_BSN_L3_INTERFACE_CLASS_ID_CLEAR(_match) \
    MEMSET(&(_match)->masks.bsn_l3_interface_class_id, 0, \
        sizeof(((_match)->masks).bsn_l3_interface_class_id))

/**
 * Test whether the match is exact for bsn_l3_interface_class_id
 */
#define OF_MATCH_MASK_BSN_L3_INTERFACE_CLASS_ID_EXACT_TEST(_match) \
    OF_VARIABLE_IS_ALL_ONES(&(((_match)->masks).bsn_l3_interface_class_id))

/**
 * Test whether key bsn_l3_interface_class_id is being checked in the match
 */
#define OF_MATCH_MASK_BSN_L3_INTERFACE_CLASS_ID_ACTIVE_TEST(_match) \
    OF_VARIABLE_IS_NON_ZERO(&(((_match)->masks).bsn_l3_interface_class_id))


/* Mask/value check/set macros for ofdpa_traffic_class */

/**
 * Set the mask for an exact match of ofdpa_traffic_class
 */
#define OF_MATCH_MASK_OFDPA_TRAFFIC_CLASS_EXACT_SET(_match)   \
    MEMSET(&(_match)->masks.ofdpa_traffic_class, 0xff, \
        sizeof(((_match)->masks).ofdpa_traffic_class))

/**
 * Clear the mask for ofdpa_traffic_class making that field inactive for the match
 */
#define OF_MATCH_MASK_OFDPA_TRAFFIC_CLASS_CLEAR(_match) \
    MEMSET(&(_match)->masks.ofdpa_traffic_class, 0, \
        sizeof(((_match)->masks).ofdpa_traffic_class))

/**
 * Test whether the match is exact for ofdpa_traffic_class
 */
#define OF_MATCH_MASK_OFDPA_TRAFFIC_CLASS_EXACT_TEST(_match) \
    OF_VARIABLE_IS_ALL_ONES(&(((_match)->masks).ofdpa_traffic_class))

/**
 * Test whether key ofdpa_traffic_class is being checked in the match
 */
#define OF_MATCH_MASK_OFDPA_TRAFFIC_CLASS_ACTIVE_TEST(_match) \
    OF_VARIABLE_IS_NON_ZERO(&(((_match)->masks).ofdpa_traffic_class))


/* Mask/value check/set macros for mpls_bos */

/**
 * Set the mask for an exact match of mpls_bos
 */
#define OF_MATCH_MASK_MPLS_BOS_EXACT_SET(_match)   \
    MEMSET(&(_match)->masks.mpls_bos, 0xff, \
        sizeof(((_match)->masks).mpls_bos))

/**
 * Clear the mask for mpls_bos making that field inactive for the match
 */
#define OF_MATCH_MASK_MPLS_BOS_CLEAR(_match) \
    MEMSET(&(_match)->masks.mpls_bos, 0, \
        sizeof(((_match)->masks).mpls_bos))

/**
 * Test whether the match is exact for mpls_bos
 */
#define OF_MATCH_MASK_MPLS_BOS_EXACT_TEST(_match) \
    OF_VARIABLE_IS_ALL_ONES(&(((_match)->masks).mpls_bos))

/**
 * Test whether key mpls_bos is being checked in the match
 */
#define OF_MATCH_MASK_MPLS_BOS_ACTIVE_TEST(_match) \
    OF_VARIABLE_IS_NON_ZERO(&(((_match)->masks).mpls_bos))


/* Mask/value check/set macros for ofdpa_oam_y1731_mdl */

/**
 * Set the mask for an exact match of ofdpa_oam_y1731_mdl
 */
#define OF_MATCH_MASK_OFDPA_OAM_Y1731_MDL_EXACT_SET(_match)   \
    MEMSET(&(_match)->masks.ofdpa_oam_y1731_mdl, 0xff, \
        sizeof(((_match)->masks).ofdpa_oam_y1731_mdl))

/**
 * Clear the mask for ofdpa_oam_y1731_mdl making that field inactive for the match
 */
#define OF_MATCH_MASK_OFDPA_OAM_Y1731_MDL_CLEAR(_match) \
    MEMSET(&(_match)->masks.ofdpa_oam_y1731_mdl, 0, \
        sizeof(((_match)->masks).ofdpa_oam_y1731_mdl))

/**
 * Test whether the match is exact for ofdpa_oam_y1731_mdl
 */
#define OF_MATCH_MASK_OFDPA_OAM_Y1731_MDL_EXACT_TEST(_match) \
    OF_VARIABLE_IS_ALL_ONES(&(((_match)->masks).ofdpa_oam_y1731_mdl))

/**
 * Test whether key ofdpa_oam_y1731_mdl is being checked in the match
 */
#define OF_MATCH_MASK_OFDPA_OAM_Y1731_MDL_ACTIVE_TEST(_match) \
    OF_VARIABLE_IS_NON_ZERO(&(((_match)->masks).ofdpa_oam_y1731_mdl))


/* Mask/value check/set macros for tcp_src */

/**
 * Set the mask for an exact match of tcp_src
 */
#define OF_MATCH_MASK_TCP_SRC_EXACT_SET(_match)   \
    MEMSET(&(_match)->masks.tcp_src, 0xff, \
        sizeof(((_match)->masks).tcp_src))

/**
 * Clear the mask for tcp_src making that field inactive for the match
 */
#define OF_MATCH_MASK_TCP_SRC_CLEAR(_match) \
    MEMSET(&(_match)->masks.tcp_src, 0, \
        sizeof(((_match)->masks).tcp_src))

/**
 * Test whether the match is exact for tcp_src
 */
#define OF_MATCH_MASK_TCP_SRC_EXACT_TEST(_match) \
    OF_VARIABLE_IS_ALL_ONES(&(((_match)->masks).tcp_src))

/**
 * Test whether key tcp_src is being checked in the match
 */
#define OF_MATCH_MASK_TCP_SRC_ACTIVE_TEST(_match) \
    OF_VARIABLE_IS_NON_ZERO(&(((_match)->masks).tcp_src))


/* Mask/value check/set macros for arp_spa */

/**
 * Set the mask for an exact match of arp_spa
 */
#define OF_MATCH_MASK_ARP_SPA_EXACT_SET(_match)   \
    MEMSET(&(_match)->masks.arp_spa, 0xff, \
        sizeof(((_match)->masks).arp_spa))

/**
 * Clear the mask for arp_spa making that field inactive for the match
 */
#define OF_MATCH_MASK_ARP_SPA_CLEAR(_match) \
    MEMSET(&(_match)->masks.arp_spa, 0, \
        sizeof(((_match)->masks).arp_spa))

/**
 * Test whether the match is exact for arp_spa
 */
#define OF_MATCH_MASK_ARP_SPA_EXACT_TEST(_match) \
    OF_VARIABLE_IS_ALL_ONES(&(((_match)->masks).arp_spa))

/**
 * Test whether key arp_spa is being checked in the match
 */
#define OF_MATCH_MASK_ARP_SPA_ACTIVE_TEST(_match) \
    OF_VARIABLE_IS_NON_ZERO(&(((_match)->masks).arp_spa))


/* Mask/value check/set macros for in_port */

/**
 * Set the mask for an exact match of in_port
 */
#define OF_MATCH_MASK_IN_PORT_EXACT_SET(_match)   \
    MEMSET(&(_match)->masks.in_port, 0xff, \
        sizeof(((_match)->masks).in_port))

/**
 * Clear the mask for in_port making that field inactive for the match
 */
#define OF_MATCH_MASK_IN_PORT_CLEAR(_match) \
    MEMSET(&(_match)->masks.in_port, 0, \
        sizeof(((_match)->masks).in_port))

/**
 * Test whether the match is exact for in_port
 */
#define OF_MATCH_MASK_IN_PORT_EXACT_TEST(_match) \
    OF_VARIABLE_IS_ALL_ONES(&(((_match)->masks).in_port))

/**
 * Test whether key in_port is being checked in the match
 */
#define OF_MATCH_MASK_IN_PORT_ACTIVE_TEST(_match) \
    OF_VARIABLE_IS_NON_ZERO(&(((_match)->masks).in_port))


/* Mask/value check/set macros for ofdpa_dei */

/**
 * Set the mask for an exact match of ofdpa_dei
 */
#define OF_MATCH_MASK_OFDPA_DEI_EXACT_SET(_match)   \
    MEMSET(&(_match)->masks.ofdpa_dei, 0xff, \
        sizeof(((_match)->masks).ofdpa_dei))

/**
 * Clear the mask for ofdpa_dei making that field inactive for the match
 */
#define OF_MATCH_MASK_OFDPA_DEI_CLEAR(_match) \
    MEMSET(&(_match)->masks.ofdpa_dei, 0, \
        sizeof(((_match)->masks).ofdpa_dei))

/**
 * Test whether the match is exact for ofdpa_dei
 */
#define OF_MATCH_MASK_OFDPA_DEI_EXACT_TEST(_match) \
    OF_VARIABLE_IS_ALL_ONES(&(((_match)->masks).ofdpa_dei))

/**
 * Test whether key ofdpa_dei is being checked in the match
 */
#define OF_MATCH_MASK_OFDPA_DEI_ACTIVE_TEST(_match) \
    OF_VARIABLE_IS_NON_ZERO(&(((_match)->masks).ofdpa_dei))


/* Mask/value check/set macros for udp_dst */

/**
 * Set the mask for an exact match of udp_dst
 */
#define OF_MATCH_MASK_UDP_DST_EXACT_SET(_match)   \
    MEMSET(&(_match)->masks.udp_dst, 0xff, \
        sizeof(((_match)->masks).udp_dst))

/**
 * Clear the mask for udp_dst making that field inactive for the match
 */
#define OF_MATCH_MASK_UDP_DST_CLEAR(_match) \
    MEMSET(&(_match)->masks.udp_dst, 0, \
        sizeof(((_match)->masks).udp_dst))

/**
 * Test whether the match is exact for udp_dst
 */
#define OF_MATCH_MASK_UDP_DST_EXACT_TEST(_match) \
    OF_VARIABLE_IS_ALL_ONES(&(((_match)->masks).udp_dst))

/**
 * Test whether key udp_dst is being checked in the match
 */
#define OF_MATCH_MASK_UDP_DST_ACTIVE_TEST(_match) \
    OF_VARIABLE_IS_NON_ZERO(&(((_match)->masks).udp_dst))


/* Mask/value check/set macros for ipv6_nd_target */

/**
 * Set the mask for an exact match of ipv6_nd_target
 */
#define OF_MATCH_MASK_IPV6_ND_TARGET_EXACT_SET(_match)   \
    MEMSET(&(_match)->masks.ipv6_nd_target, 0xff, \
        sizeof(((_match)->masks).ipv6_nd_target))

/**
 * Clear the mask for ipv6_nd_target making that field inactive for the match
 */
#define OF_MATCH_MASK_IPV6_ND_TARGET_CLEAR(_match) \
    MEMSET(&(_match)->masks.ipv6_nd_target, 0, \
        sizeof(((_match)->masks).ipv6_nd_target))

/**
 * Test whether the match is exact for ipv6_nd_target
 */
#define OF_MATCH_MASK_IPV6_ND_TARGET_EXACT_TEST(_match) \
    OF_VARIABLE_IS_ALL_ONES(&(((_match)->masks).ipv6_nd_target))

/**
 * Test whether key ipv6_nd_target is being checked in the match
 */
#define OF_MATCH_MASK_IPV6_ND_TARGET_ACTIVE_TEST(_match) \
    OF_VARIABLE_IS_NON_ZERO(&(((_match)->masks).ipv6_nd_target))


/* Mask/value check/set macros for icmpv6_type */

/**
 * Set the mask for an exact match of icmpv6_type
 */
#define OF_MATCH_MASK_ICMPV6_TYPE_EXACT_SET(_match)   \
    MEMSET(&(_match)->masks.icmpv6_type, 0xff, \
        sizeof(((_match)->masks).icmpv6_type))

/**
 * Clear the mask for icmpv6_type making that field inactive for the match
 */
#define OF_MATCH_MASK_ICMPV6_TYPE_CLEAR(_match) \
    MEMSET(&(_match)->masks.icmpv6_type, 0, \
        sizeof(((_match)->masks).icmpv6_type))

/**
 * Test whether the match is exact for icmpv6_type
 */
#define OF_MATCH_MASK_ICMPV6_TYPE_EXACT_TEST(_match) \
    OF_VARIABLE_IS_ALL_ONES(&(((_match)->masks).icmpv6_type))

/**
 * Test whether key icmpv6_type is being checked in the match
 */
#define OF_MATCH_MASK_ICMPV6_TYPE_ACTIVE_TEST(_match) \
    OF_VARIABLE_IS_NON_ZERO(&(((_match)->masks).icmpv6_type))


/* Mask/value check/set macros for ofdpa_txfcl */

/**
 * Set the mask for an exact match of ofdpa_txfcl
 */
#define OF_MATCH_MASK_OFDPA_TXFCL_EXACT_SET(_match)   \
    MEMSET(&(_match)->masks.ofdpa_txfcl, 0xff, \
        sizeof(((_match)->masks).ofdpa_txfcl))

/**
 * Clear the mask for ofdpa_txfcl making that field inactive for the match
 */
#define OF_MATCH_MASK_OFDPA_TXFCL_CLEAR(_match) \
    MEMSET(&(_match)->masks.ofdpa_txfcl, 0, \
        sizeof(((_match)->masks).ofdpa_txfcl))

/**
 * Test whether the match is exact for ofdpa_txfcl
 */
#define OF_MATCH_MASK_OFDPA_TXFCL_EXACT_TEST(_match) \
    OF_VARIABLE_IS_ALL_ONES(&(((_match)->masks).ofdpa_txfcl))

/**
 * Test whether key ofdpa_txfcl is being checked in the match
 */
#define OF_MATCH_MASK_OFDPA_TXFCL_ACTIVE_TEST(_match) \
    OF_VARIABLE_IS_NON_ZERO(&(((_match)->masks).ofdpa_txfcl))


/* Mask/value check/set macros for ofdpa_bfd_discriminator */

/**
 * Set the mask for an exact match of ofdpa_bfd_discriminator
 */
#define OF_MATCH_MASK_OFDPA_BFD_DISCRIMINATOR_EXACT_SET(_match)   \
    MEMSET(&(_match)->masks.ofdpa_bfd_discriminator, 0xff, \
        sizeof(((_match)->masks).ofdpa_bfd_discriminator))

/**
 * Clear the mask for ofdpa_bfd_discriminator making that field inactive for the match
 */
#define OF_MATCH_MASK_OFDPA_BFD_DISCRIMINATOR_CLEAR(_match) \
    MEMSET(&(_match)->masks.ofdpa_bfd_discriminator, 0, \
        sizeof(((_match)->masks).ofdpa_bfd_discriminator))

/**
 * Test whether the match is exact for ofdpa_bfd_discriminator
 */
#define OF_MATCH_MASK_OFDPA_BFD_DISCRIMINATOR_EXACT_TEST(_match) \
    OF_VARIABLE_IS_ALL_ONES(&(((_match)->masks).ofdpa_bfd_discriminator))

/**
 * Test whether key ofdpa_bfd_discriminator is being checked in the match
 */
#define OF_MATCH_MASK_OFDPA_BFD_DISCRIMINATOR_ACTIVE_TEST(_match) \
    OF_VARIABLE_IS_NON_ZERO(&(((_match)->masks).ofdpa_bfd_discriminator))


/* Mask/value check/set macros for icmpv4_type */

/**
 * Set the mask for an exact match of icmpv4_type
 */
#define OF_MATCH_MASK_ICMPV4_TYPE_EXACT_SET(_match)   \
    MEMSET(&(_match)->masks.icmpv4_type, 0xff, \
        sizeof(((_match)->masks).icmpv4_type))

/**
 * Clear the mask for icmpv4_type making that field inactive for the match
 */
#define OF_MATCH_MASK_ICMPV4_TYPE_CLEAR(_match) \
    MEMSET(&(_match)->masks.icmpv4_type, 0, \
        sizeof(((_match)->masks).icmpv4_type))

/**
 * Test whether the match is exact for icmpv4_type
 */
#define OF_MATCH_MASK_ICMPV4_TYPE_EXACT_TEST(_match) \
    OF_VARIABLE_IS_ALL_ONES(&(((_match)->masks).icmpv4_type))

/**
 * Test whether key icmpv4_type is being checked in the match
 */
#define OF_MATCH_MASK_ICMPV4_TYPE_ACTIVE_TEST(_match) \
    OF_VARIABLE_IS_NON_ZERO(&(((_match)->masks).icmpv4_type))


/* Mask/value check/set macros for mpls_label */

/**
 * Set the mask for an exact match of mpls_label
 */
#define OF_MATCH_MASK_MPLS_LABEL_EXACT_SET(_match)   \
    MEMSET(&(_match)->masks.mpls_label, 0xff, \
        sizeof(((_match)->masks).mpls_label))

/**
 * Clear the mask for mpls_label making that field inactive for the match
 */
#define OF_MATCH_MASK_MPLS_LABEL_CLEAR(_match) \
    MEMSET(&(_match)->masks.mpls_label, 0, \
        sizeof(((_match)->masks).mpls_label))

/**
 * Test whether the match is exact for mpls_label
 */
#define OF_MATCH_MASK_MPLS_LABEL_EXACT_TEST(_match) \
    OF_VARIABLE_IS_ALL_ONES(&(((_match)->masks).mpls_label))

/**
 * Test whether key mpls_label is being checked in the match
 */
#define OF_MATCH_MASK_MPLS_LABEL_ACTIVE_TEST(_match) \
    OF_VARIABLE_IS_NON_ZERO(&(((_match)->masks).mpls_label))


/* Mask/value check/set macros for tcp_dst */

/**
 * Set the mask for an exact match of tcp_dst
 */
#define OF_MATCH_MASK_TCP_DST_EXACT_SET(_match)   \
    MEMSET(&(_match)->masks.tcp_dst, 0xff, \
        sizeof(((_match)->masks).tcp_dst))

/**
 * Clear the mask for tcp_dst making that field inactive for the match
 */
#define OF_MATCH_MASK_TCP_DST_CLEAR(_match) \
    MEMSET(&(_match)->masks.tcp_dst, 0, \
        sizeof(((_match)->masks).tcp_dst))

/**
 * Test whether the match is exact for tcp_dst
 */
#define OF_MATCH_MASK_TCP_DST_EXACT_TEST(_match) \
    OF_VARIABLE_IS_ALL_ONES(&(((_match)->masks).tcp_dst))

/**
 * Test whether key tcp_dst is being checked in the match
 */
#define OF_MATCH_MASK_TCP_DST_ACTIVE_TEST(_match) \
    OF_VARIABLE_IS_NON_ZERO(&(((_match)->masks).tcp_dst))


/* Mask/value check/set macros for ip_proto */

/**
 * Set the mask for an exact match of ip_proto
 */
#define OF_MATCH_MASK_IP_PROTO_EXACT_SET(_match)   \
    MEMSET(&(_match)->masks.ip_proto, 0xff, \
        sizeof(((_match)->masks).ip_proto))

/**
 * Clear the mask for ip_proto making that field inactive for the match
 */
#define OF_MATCH_MASK_IP_PROTO_CLEAR(_match) \
    MEMSET(&(_match)->masks.ip_proto, 0, \
        sizeof(((_match)->masks).ip_proto))

/**
 * Test whether the match is exact for ip_proto
 */
#define OF_MATCH_MASK_IP_PROTO_EXACT_TEST(_match) \
    OF_VARIABLE_IS_ALL_ONES(&(((_match)->masks).ip_proto))

/**
 * Test whether key ip_proto is being checked in the match
 */
#define OF_MATCH_MASK_IP_PROTO_ACTIVE_TEST(_match) \
    OF_VARIABLE_IS_NON_ZERO(&(((_match)->masks).ip_proto))


/* Mask/value check/set macros for ofdpa_ovid */

/**
 * Set the mask for an exact match of ofdpa_ovid
 */
#define OF_MATCH_MASK_OFDPA_OVID_EXACT_SET(_match)   \
    MEMSET(&(_match)->masks.ofdpa_ovid, 0xff, \
        sizeof(((_match)->masks).ofdpa_ovid))

/**
 * Clear the mask for ofdpa_ovid making that field inactive for the match
 */
#define OF_MATCH_MASK_OFDPA_OVID_CLEAR(_match) \
    MEMSET(&(_match)->masks.ofdpa_ovid, 0, \
        sizeof(((_match)->masks).ofdpa_ovid))

/**
 * Test whether the match is exact for ofdpa_ovid
 */
#define OF_MATCH_MASK_OFDPA_OVID_EXACT_TEST(_match) \
    OF_VARIABLE_IS_ALL_ONES(&(((_match)->masks).ofdpa_ovid))

/**
 * Test whether key ofdpa_ovid is being checked in the match
 */
#define OF_MATCH_MASK_OFDPA_OVID_ACTIVE_TEST(_match) \
    OF_VARIABLE_IS_NON_ZERO(&(((_match)->masks).ofdpa_ovid))


/* Mask/value check/set macros for ip_dscp */

/**
 * Set the mask for an exact match of ip_dscp
 */
#define OF_MATCH_MASK_IP_DSCP_EXACT_SET(_match)   \
    MEMSET(&(_match)->masks.ip_dscp, 0xff, \
        sizeof(((_match)->masks).ip_dscp))

/**
 * Clear the mask for ip_dscp making that field inactive for the match
 */
#define OF_MATCH_MASK_IP_DSCP_CLEAR(_match) \
    MEMSET(&(_match)->masks.ip_dscp, 0, \
        sizeof(((_match)->masks).ip_dscp))

/**
 * Test whether the match is exact for ip_dscp
 */
#define OF_MATCH_MASK_IP_DSCP_EXACT_TEST(_match) \
    OF_VARIABLE_IS_ALL_ONES(&(((_match)->masks).ip_dscp))

/**
 * Test whether key ip_dscp is being checked in the match
 */
#define OF_MATCH_MASK_IP_DSCP_ACTIVE_TEST(_match) \
    OF_VARIABLE_IS_NON_ZERO(&(((_match)->masks).ip_dscp))


/* Mask/value check/set macros for ofdpa_allow_vlan_translation */

/**
 * Set the mask for an exact match of ofdpa_allow_vlan_translation
 */
#define OF_MATCH_MASK_OFDPA_ALLOW_VLAN_TRANSLATION_EXACT_SET(_match)   \
    MEMSET(&(_match)->masks.ofdpa_allow_vlan_translation, 0xff, \
        sizeof(((_match)->masks).ofdpa_allow_vlan_translation))

/**
 * Clear the mask for ofdpa_allow_vlan_translation making that field inactive for the match
 */
#define OF_MATCH_MASK_OFDPA_ALLOW_VLAN_TRANSLATION_CLEAR(_match) \
    MEMSET(&(_match)->masks.ofdpa_allow_vlan_translation, 0, \
        sizeof(((_match)->masks).ofdpa_allow_vlan_translation))

/**
 * Test whether the match is exact for ofdpa_allow_vlan_translation
 */
#define OF_MATCH_MASK_OFDPA_ALLOW_VLAN_TRANSLATION_EXACT_TEST(_match) \
    OF_VARIABLE_IS_ALL_ONES(&(((_match)->masks).ofdpa_allow_vlan_translation))

/**
 * Test whether key ofdpa_allow_vlan_translation is being checked in the match
 */
#define OF_MATCH_MASK_OFDPA_ALLOW_VLAN_TRANSLATION_ACTIVE_TEST(_match) \
    OF_VARIABLE_IS_NON_ZERO(&(((_match)->masks).ofdpa_allow_vlan_translation))


/* Mask/value check/set macros for ofdpa_mpls_l2_port */

/**
 * Set the mask for an exact match of ofdpa_mpls_l2_port
 */
#define OF_MATCH_MASK_OFDPA_MPLS_L2_PORT_EXACT_SET(_match)   \
    MEMSET(&(_match)->masks.ofdpa_mpls_l2_port, 0xff, \
        sizeof(((_match)->masks).ofdpa_mpls_l2_port))

/**
 * Clear the mask for ofdpa_mpls_l2_port making that field inactive for the match
 */
#define OF_MATCH_MASK_OFDPA_MPLS_L2_PORT_CLEAR(_match) \
    MEMSET(&(_match)->masks.ofdpa_mpls_l2_port, 0, \
        sizeof(((_match)->masks).ofdpa_mpls_l2_port))

/**
 * Test whether the match is exact for ofdpa_mpls_l2_port
 */
#define OF_MATCH_MASK_OFDPA_MPLS_L2_PORT_EXACT_TEST(_match) \
    OF_VARIABLE_IS_ALL_ONES(&(((_match)->masks).ofdpa_mpls_l2_port))

/**
 * Test whether key ofdpa_mpls_l2_port is being checked in the match
 */
#define OF_MATCH_MASK_OFDPA_MPLS_L2_PORT_ACTIVE_TEST(_match) \
    OF_VARIABLE_IS_NON_ZERO(&(((_match)->masks).ofdpa_mpls_l2_port))


/* Mask/value check/set macros for ofdpa_mpls_data_first_nibble */

/**
 * Set the mask for an exact match of ofdpa_mpls_data_first_nibble
 */
#define OF_MATCH_MASK_OFDPA_MPLS_DATA_FIRST_NIBBLE_EXACT_SET(_match)   \
    MEMSET(&(_match)->masks.ofdpa_mpls_data_first_nibble, 0xff, \
        sizeof(((_match)->masks).ofdpa_mpls_data_first_nibble))

/**
 * Clear the mask for ofdpa_mpls_data_first_nibble making that field inactive for the match
 */
#define OF_MATCH_MASK_OFDPA_MPLS_DATA_FIRST_NIBBLE_CLEAR(_match) \
    MEMSET(&(_match)->masks.ofdpa_mpls_data_first_nibble, 0, \
        sizeof(((_match)->masks).ofdpa_mpls_data_first_nibble))

/**
 * Test whether the match is exact for ofdpa_mpls_data_first_nibble
 */
#define OF_MATCH_MASK_OFDPA_MPLS_DATA_FIRST_NIBBLE_EXACT_TEST(_match) \
    OF_VARIABLE_IS_ALL_ONES(&(((_match)->masks).ofdpa_mpls_data_first_nibble))

/**
 * Test whether key ofdpa_mpls_data_first_nibble is being checked in the match
 */
#define OF_MATCH_MASK_OFDPA_MPLS_DATA_FIRST_NIBBLE_ACTIVE_TEST(_match) \
    OF_VARIABLE_IS_NON_ZERO(&(((_match)->masks).ofdpa_mpls_data_first_nibble))


/* Mask/value check/set macros for ipv6_flabel */

/**
 * Set the mask for an exact match of ipv6_flabel
 */
#define OF_MATCH_MASK_IPV6_FLABEL_EXACT_SET(_match)   \
    MEMSET(&(_match)->masks.ipv6_flabel, 0xff, \
        sizeof(((_match)->masks).ipv6_flabel))

/**
 * Clear the mask for ipv6_flabel making that field inactive for the match
 */
#define OF_MATCH_MASK_IPV6_FLABEL_CLEAR(_match) \
    MEMSET(&(_match)->masks.ipv6_flabel, 0, \
        sizeof(((_match)->masks).ipv6_flabel))

/**
 * Test whether the match is exact for ipv6_flabel
 */
#define OF_MATCH_MASK_IPV6_FLABEL_EXACT_TEST(_match) \
    OF_VARIABLE_IS_ALL_ONES(&(((_match)->masks).ipv6_flabel))

/**
 * Test whether key ipv6_flabel is being checked in the match
 */
#define OF_MATCH_MASK_IPV6_FLABEL_ACTIVE_TEST(_match) \
    OF_VARIABLE_IS_NON_ZERO(&(((_match)->masks).ipv6_flabel))


/* Mask/value check/set macros for onf_actset_output */

/**
 * Set the mask for an exact match of onf_packet_regs0
 */
#define OF_MATCH_MASK_ONF_PKT_REG0_EXACT_SET(_match)   \
    MEMSET(&(_match)->masks.onf_packet_regs0, 0xff, \
        sizeof(((_match)->masks).onf_packet_regs0))

/* Mask/value check/set macros for onf_actset_output */


/**
 * Set the mask for an exact match of onf_actset_output
 */
#define OF_MATCH_MASK_ONF_ACTSET_OUTPUT_EXACT_SET(_match)   \
    MEMSET(&(_match)->masks.onf_actset_output, 0xff, \
        sizeof(((_match)->masks).onf_actset_output))

/**
 * Clear the mask for onf_actset_output making that field inactive for the match
 */
#define OF_MATCH_MASK_ONF_ACTSET_OUTPUT_CLEAR(_match) \
    MEMSET(&(_match)->masks.onf_actset_output, 0, \
        sizeof(((_match)->masks).onf_actset_output))

/**
 * Test whether the match is exact for onf_actset_output
 */
#define OF_MATCH_MASK_ONF_ACTSET_OUTPUT_EXACT_TEST(_match) \
    OF_VARIABLE_IS_ALL_ONES(&(((_match)->masks).onf_actset_output))

/**
 * Test whether key onf_actset_output is being checked in the match
 */
#define OF_MATCH_MASK_ONF_ACTSET_OUTPUT_ACTIVE_TEST(_match) \
    OF_VARIABLE_IS_NON_ZERO(&(((_match)->masks).onf_actset_output))


/* Mask/value check/set macros for arp_tpa */

/**
 * Set the mask for an exact match of arp_tpa
 */
#define OF_MATCH_MASK_ARP_TPA_EXACT_SET(_match)   \
    MEMSET(&(_match)->masks.arp_tpa, 0xff, \
        sizeof(((_match)->masks).arp_tpa))

/**
 * Clear the mask for arp_tpa making that field inactive for the match
 */
#define OF_MATCH_MASK_ARP_TPA_CLEAR(_match) \
    MEMSET(&(_match)->masks.arp_tpa, 0, \
        sizeof(((_match)->masks).arp_tpa))

/**
 * Test whether the match is exact for arp_tpa
 */
#define OF_MATCH_MASK_ARP_TPA_EXACT_TEST(_match) \
    OF_VARIABLE_IS_ALL_ONES(&(((_match)->masks).arp_tpa))

/**
 * Test whether key arp_tpa is being checked in the match
 */
#define OF_MATCH_MASK_ARP_TPA_ACTIVE_TEST(_match) \
    OF_VARIABLE_IS_NON_ZERO(&(((_match)->masks).arp_tpa))


/* Mask/value check/set macros for ipv6_src */

/**
 * Set the mask for an exact match of ipv6_src
 */
#define OF_MATCH_MASK_IPV6_SRC_EXACT_SET(_match)   \
    MEMSET(&(_match)->masks.ipv6_src, 0xff, \
        sizeof(((_match)->masks).ipv6_src))

/**
 * Clear the mask for ipv6_src making that field inactive for the match
 */
#define OF_MATCH_MASK_IPV6_SRC_CLEAR(_match) \
    MEMSET(&(_match)->masks.ipv6_src, 0, \
        sizeof(((_match)->masks).ipv6_src))

/**
 * Test whether the match is exact for ipv6_src
 */
#define OF_MATCH_MASK_IPV6_SRC_EXACT_TEST(_match) \
    OF_VARIABLE_IS_ALL_ONES(&(((_match)->masks).ipv6_src))

/**
 * Test whether key ipv6_src is being checked in the match
 */
#define OF_MATCH_MASK_IPV6_SRC_ACTIVE_TEST(_match) \
    OF_VARIABLE_IS_NON_ZERO(&(((_match)->masks).ipv6_src))


/* Mask/value check/set macros for bsn_in_ports_128 */

/**
 * Set the mask for an exact match of bsn_in_ports_128
 */
#define OF_MATCH_MASK_BSN_IN_PORTS_128_EXACT_SET(_match)   \
    MEMSET(&(_match)->masks.bsn_in_ports_128, 0xff, \
        sizeof(((_match)->masks).bsn_in_ports_128))

/**
 * Clear the mask for bsn_in_ports_128 making that field inactive for the match
 */
#define OF_MATCH_MASK_BSN_IN_PORTS_128_CLEAR(_match) \
    MEMSET(&(_match)->masks.bsn_in_ports_128, 0, \
        sizeof(((_match)->masks).bsn_in_ports_128))

/**
 * Test whether the match is exact for bsn_in_ports_128
 */
#define OF_MATCH_MASK_BSN_IN_PORTS_128_EXACT_TEST(_match) \
    OF_VARIABLE_IS_ALL_ONES(&(((_match)->masks).bsn_in_ports_128))

/**
 * Test whether key bsn_in_ports_128 is being checked in the match
 */
#define OF_MATCH_MASK_BSN_IN_PORTS_128_ACTIVE_TEST(_match) \
    OF_VARIABLE_IS_NON_ZERO(&(((_match)->masks).bsn_in_ports_128))


/* Mask/value check/set macros for eth_src */

/**
 * Set the mask for an exact match of eth_src
 */
#define OF_MATCH_MASK_ETH_SRC_EXACT_SET(_match)   \
    MEMSET(&(_match)->masks.eth_src, 0xff, \
        sizeof(((_match)->masks).eth_src))

/**
 * Clear the mask for eth_src making that field inactive for the match
 */
#define OF_MATCH_MASK_ETH_SRC_CLEAR(_match) \
    MEMSET(&(_match)->masks.eth_src, 0, \
        sizeof(((_match)->masks).eth_src))

/**
 * Test whether the match is exact for eth_src
 */
#define OF_MATCH_MASK_ETH_SRC_EXACT_TEST(_match) \
    OF_VARIABLE_IS_ALL_ONES(&(((_match)->masks).eth_src))

/**
 * Test whether key eth_src is being checked in the match
 */
#define OF_MATCH_MASK_ETH_SRC_ACTIVE_TEST(_match) \
    OF_VARIABLE_IS_NON_ZERO(&(((_match)->masks).eth_src))


/* Mask/value check/set macros for ofdpa_l3_in_port */

/**
 * Set the mask for an exact match of ofdpa_l3_in_port
 */
#define OF_MATCH_MASK_OFDPA_L3_IN_PORT_EXACT_SET(_match)   \
    MEMSET(&(_match)->masks.ofdpa_l3_in_port, 0xff, \
        sizeof(((_match)->masks).ofdpa_l3_in_port))

/**
 * Clear the mask for ofdpa_l3_in_port making that field inactive for the match
 */
#define OF_MATCH_MASK_OFDPA_L3_IN_PORT_CLEAR(_match) \
    MEMSET(&(_match)->masks.ofdpa_l3_in_port, 0, \
        sizeof(((_match)->masks).ofdpa_l3_in_port))

/**
 * Test whether the match is exact for ofdpa_l3_in_port
 */
#define OF_MATCH_MASK_OFDPA_L3_IN_PORT_EXACT_TEST(_match) \
    OF_VARIABLE_IS_ALL_ONES(&(((_match)->masks).ofdpa_l3_in_port))

/**
 * Test whether key ofdpa_l3_in_port is being checked in the match
 */
#define OF_MATCH_MASK_OFDPA_L3_IN_PORT_ACTIVE_TEST(_match) \
    OF_VARIABLE_IS_NON_ZERO(&(((_match)->masks).ofdpa_l3_in_port))


/* Mask/value check/set macros for ofdpa_oam_y1731_opcode */

/**
 * Set the mask for an exact match of ofdpa_oam_y1731_opcode
 */
#define OF_MATCH_MASK_OFDPA_OAM_Y1731_OPCODE_EXACT_SET(_match)   \
    MEMSET(&(_match)->masks.ofdpa_oam_y1731_opcode, 0xff, \
        sizeof(((_match)->masks).ofdpa_oam_y1731_opcode))

/**
 * Clear the mask for ofdpa_oam_y1731_opcode making that field inactive for the match
 */
#define OF_MATCH_MASK_OFDPA_OAM_Y1731_OPCODE_CLEAR(_match) \
    MEMSET(&(_match)->masks.ofdpa_oam_y1731_opcode, 0, \
        sizeof(((_match)->masks).ofdpa_oam_y1731_opcode))

/**
 * Test whether the match is exact for ofdpa_oam_y1731_opcode
 */
#define OF_MATCH_MASK_OFDPA_OAM_Y1731_OPCODE_EXACT_TEST(_match) \
    OF_VARIABLE_IS_ALL_ONES(&(((_match)->masks).ofdpa_oam_y1731_opcode))

/**
 * Test whether key ofdpa_oam_y1731_opcode is being checked in the match
 */
#define OF_MATCH_MASK_OFDPA_OAM_Y1731_OPCODE_ACTIVE_TEST(_match) \
    OF_VARIABLE_IS_NON_ZERO(&(((_match)->masks).ofdpa_oam_y1731_opcode))


/* Mask/value check/set macros for bsn_l3_dst_class_id */

/**
 * Set the mask for an exact match of bsn_l3_dst_class_id
 */
#define OF_MATCH_MASK_BSN_L3_DST_CLASS_ID_EXACT_SET(_match)   \
    MEMSET(&(_match)->masks.bsn_l3_dst_class_id, 0xff, \
        sizeof(((_match)->masks).bsn_l3_dst_class_id))

/**
 * Clear the mask for bsn_l3_dst_class_id making that field inactive for the match
 */
#define OF_MATCH_MASK_BSN_L3_DST_CLASS_ID_CLEAR(_match) \
    MEMSET(&(_match)->masks.bsn_l3_dst_class_id, 0, \
        sizeof(((_match)->masks).bsn_l3_dst_class_id))

/**
 * Test whether the match is exact for bsn_l3_dst_class_id
 */
#define OF_MATCH_MASK_BSN_L3_DST_CLASS_ID_EXACT_TEST(_match) \
    OF_VARIABLE_IS_ALL_ONES(&(((_match)->masks).bsn_l3_dst_class_id))

/**
 * Test whether key bsn_l3_dst_class_id is being checked in the match
 */
#define OF_MATCH_MASK_BSN_L3_DST_CLASS_ID_ACTIVE_TEST(_match) \
    OF_VARIABLE_IS_NON_ZERO(&(((_match)->masks).bsn_l3_dst_class_id))


/* Mask/value check/set macros for ipv6_nd_sll */

/**
 * Set the mask for an exact match of ipv6_nd_sll
 */
#define OF_MATCH_MASK_IPV6_ND_SLL_EXACT_SET(_match)   \
    MEMSET(&(_match)->masks.ipv6_nd_sll, 0xff, \
        sizeof(((_match)->masks).ipv6_nd_sll))

/**
 * Clear the mask for ipv6_nd_sll making that field inactive for the match
 */
#define OF_MATCH_MASK_IPV6_ND_SLL_CLEAR(_match) \
    MEMSET(&(_match)->masks.ipv6_nd_sll, 0, \
        sizeof(((_match)->masks).ipv6_nd_sll))

/**
 * Test whether the match is exact for ipv6_nd_sll
 */
#define OF_MATCH_MASK_IPV6_ND_SLL_EXACT_TEST(_match) \
    OF_VARIABLE_IS_ALL_ONES(&(((_match)->masks).ipv6_nd_sll))

/**
 * Test whether key ipv6_nd_sll is being checked in the match
 */
#define OF_MATCH_MASK_IPV6_ND_SLL_ACTIVE_TEST(_match) \
    OF_VARIABLE_IS_NON_ZERO(&(((_match)->masks).ipv6_nd_sll))


/* Mask/value check/set macros for mpls_tc */

/**
 * Set the mask for an exact match of mpls_tc
 */
#define OF_MATCH_MASK_MPLS_TC_EXACT_SET(_match)   \
    MEMSET(&(_match)->masks.mpls_tc, 0xff, \
        sizeof(((_match)->masks).mpls_tc))

/**
 * Clear the mask for mpls_tc making that field inactive for the match
 */
#define OF_MATCH_MASK_MPLS_TC_CLEAR(_match) \
    MEMSET(&(_match)->masks.mpls_tc, 0, \
        sizeof(((_match)->masks).mpls_tc))

/**
 * Test whether the match is exact for mpls_tc
 */
#define OF_MATCH_MASK_MPLS_TC_EXACT_TEST(_match) \
    OF_VARIABLE_IS_ALL_ONES(&(((_match)->masks).mpls_tc))

/**
 * Test whether key mpls_tc is being checked in the match
 */
#define OF_MATCH_MASK_MPLS_TC_ACTIVE_TEST(_match) \
    OF_VARIABLE_IS_NON_ZERO(&(((_match)->masks).mpls_tc))


/* Mask/value check/set macros for ofdpa_protection_index */

/**
 * Set the mask for an exact match of ofdpa_protection_index
 */
#define OF_MATCH_MASK_OFDPA_PROTECTION_INDEX_EXACT_SET(_match)   \
    MEMSET(&(_match)->masks.ofdpa_protection_index, 0xff, \
        sizeof(((_match)->masks).ofdpa_protection_index))

/**
 * Clear the mask for ofdpa_protection_index making that field inactive for the match
 */
#define OF_MATCH_MASK_OFDPA_PROTECTION_INDEX_CLEAR(_match) \
    MEMSET(&(_match)->masks.ofdpa_protection_index, 0, \
        sizeof(((_match)->masks).ofdpa_protection_index))

/**
 * Test whether the match is exact for ofdpa_protection_index
 */
#define OF_MATCH_MASK_OFDPA_PROTECTION_INDEX_EXACT_TEST(_match) \
    OF_VARIABLE_IS_ALL_ONES(&(((_match)->masks).ofdpa_protection_index))

/**
 * Test whether key ofdpa_protection_index is being checked in the match
 */
#define OF_MATCH_MASK_OFDPA_PROTECTION_INDEX_ACTIVE_TEST(_match) \
    OF_VARIABLE_IS_NON_ZERO(&(((_match)->masks).ofdpa_protection_index))


/* Mask/value check/set macros for bsn_egr_port_group_id */

/**
 * Set the mask for an exact match of bsn_egr_port_group_id
 */
#define OF_MATCH_MASK_BSN_EGR_PORT_GROUP_ID_EXACT_SET(_match)   \
    MEMSET(&(_match)->masks.bsn_egr_port_group_id, 0xff, \
        sizeof(((_match)->masks).bsn_egr_port_group_id))

/**
 * Clear the mask for bsn_egr_port_group_id making that field inactive for the match
 */
#define OF_MATCH_MASK_BSN_EGR_PORT_GROUP_ID_CLEAR(_match) \
    MEMSET(&(_match)->masks.bsn_egr_port_group_id, 0, \
        sizeof(((_match)->masks).bsn_egr_port_group_id))

/**
 * Test whether the match is exact for bsn_egr_port_group_id
 */
#define OF_MATCH_MASK_BSN_EGR_PORT_GROUP_ID_EXACT_TEST(_match) \
    OF_VARIABLE_IS_ALL_ONES(&(((_match)->masks).bsn_egr_port_group_id))

/**
 * Test whether key bsn_egr_port_group_id is being checked in the match
 */
#define OF_MATCH_MASK_BSN_EGR_PORT_GROUP_ID_ACTIVE_TEST(_match) \
    OF_VARIABLE_IS_NON_ZERO(&(((_match)->masks).bsn_egr_port_group_id))


/* Mask/value check/set macros for vlan_vid */

/**
 * Set the mask for an exact match of vlan_vid
 */
#define OF_MATCH_MASK_VLAN_VID_EXACT_SET(_match)   \
    MEMSET(&(_match)->masks.vlan_vid, 0xff, \
        sizeof(((_match)->masks).vlan_vid))

/**
 * Clear the mask for vlan_vid making that field inactive for the match
 */
#define OF_MATCH_MASK_VLAN_VID_CLEAR(_match) \
    MEMSET(&(_match)->masks.vlan_vid, 0, \
        sizeof(((_match)->masks).vlan_vid))

/**
 * Test whether the match is exact for vlan_vid
 */
#define OF_MATCH_MASK_VLAN_VID_EXACT_TEST(_match) \
    OF_VARIABLE_IS_ALL_ONES(&(((_match)->masks).vlan_vid))

/**
 * Test whether key vlan_vid is being checked in the match
 */
#define OF_MATCH_MASK_VLAN_VID_ACTIVE_TEST(_match) \
    OF_VARIABLE_IS_NON_ZERO(&(((_match)->masks).vlan_vid))


/* Mask/value check/set macros for arp_tha */

/**
 * Set the mask for an exact match of arp_tha
 */
#define OF_MATCH_MASK_ARP_THA_EXACT_SET(_match)   \
    MEMSET(&(_match)->masks.arp_tha, 0xff, \
        sizeof(((_match)->masks).arp_tha))

/**
 * Clear the mask for arp_tha making that field inactive for the match
 */
#define OF_MATCH_MASK_ARP_THA_CLEAR(_match) \
    MEMSET(&(_match)->masks.arp_tha, 0, \
        sizeof(((_match)->masks).arp_tha))

/**
 * Test whether the match is exact for arp_tha
 */
#define OF_MATCH_MASK_ARP_THA_EXACT_TEST(_match) \
    OF_VARIABLE_IS_ALL_ONES(&(((_match)->masks).arp_tha))

/**
 * Test whether key arp_tha is being checked in the match
 */
#define OF_MATCH_MASK_ARP_THA_ACTIVE_TEST(_match) \
    OF_VARIABLE_IS_NON_ZERO(&(((_match)->masks).arp_tha))


/* Mask/value check/set macros for metadata */

/**
 * Set the mask for an exact match of metadata
 */
#define OF_MATCH_MASK_METADATA_EXACT_SET(_match)   \
    MEMSET(&(_match)->masks.metadata, 0xff, \
        sizeof(((_match)->masks).metadata))

/**
 * Clear the mask for metadata making that field inactive for the match
 */
#define OF_MATCH_MASK_METADATA_CLEAR(_match) \
    MEMSET(&(_match)->masks.metadata, 0, \
        sizeof(((_match)->masks).metadata))

/**
 * Test whether the match is exact for metadata
 */
#define OF_MATCH_MASK_METADATA_EXACT_TEST(_match) \
    OF_VARIABLE_IS_ALL_ONES(&(((_match)->masks).metadata))

/**
 * Test whether key metadata is being checked in the match
 */
#define OF_MATCH_MASK_METADATA_ACTIVE_TEST(_match) \
    OF_VARIABLE_IS_NON_ZERO(&(((_match)->masks).metadata))


/* Mask/value check/set macros for bsn_l3_src_class_id */

/**
 * Set the mask for an exact match of bsn_l3_src_class_id
 */
#define OF_MATCH_MASK_BSN_L3_SRC_CLASS_ID_EXACT_SET(_match)   \
    MEMSET(&(_match)->masks.bsn_l3_src_class_id, 0xff, \
        sizeof(((_match)->masks).bsn_l3_src_class_id))

/**
 * Clear the mask for bsn_l3_src_class_id making that field inactive for the match
 */
#define OF_MATCH_MASK_BSN_L3_SRC_CLASS_ID_CLEAR(_match) \
    MEMSET(&(_match)->masks.bsn_l3_src_class_id, 0, \
        sizeof(((_match)->masks).bsn_l3_src_class_id))

/**
 * Test whether the match is exact for bsn_l3_src_class_id
 */
#define OF_MATCH_MASK_BSN_L3_SRC_CLASS_ID_EXACT_TEST(_match) \
    OF_VARIABLE_IS_ALL_ONES(&(((_match)->masks).bsn_l3_src_class_id))

/**
 * Test whether key bsn_l3_src_class_id is being checked in the match
 */
#define OF_MATCH_MASK_BSN_L3_SRC_CLASS_ID_ACTIVE_TEST(_match) \
    OF_VARIABLE_IS_NON_ZERO(&(((_match)->masks).bsn_l3_src_class_id))


/* Mask/value check/set macros for sctp_dst */

/**
 * Set the mask for an exact match of sctp_dst
 */
#define OF_MATCH_MASK_SCTP_DST_EXACT_SET(_match)   \
    MEMSET(&(_match)->masks.sctp_dst, 0xff, \
        sizeof(((_match)->masks).sctp_dst))

/**
 * Clear the mask for sctp_dst making that field inactive for the match
 */
#define OF_MATCH_MASK_SCTP_DST_CLEAR(_match) \
    MEMSET(&(_match)->masks.sctp_dst, 0, \
        sizeof(((_match)->masks).sctp_dst))

/**
 * Test whether the match is exact for sctp_dst
 */
#define OF_MATCH_MASK_SCTP_DST_EXACT_TEST(_match) \
    OF_VARIABLE_IS_ALL_ONES(&(((_match)->masks).sctp_dst))

/**
 * Test whether key sctp_dst is being checked in the match
 */
#define OF_MATCH_MASK_SCTP_DST_ACTIVE_TEST(_match) \
    OF_VARIABLE_IS_NON_ZERO(&(((_match)->masks).sctp_dst))


/* Mask/value check/set macros for icmpv4_code */

/**
 * Set the mask for an exact match of icmpv4_code
 */
#define OF_MATCH_MASK_ICMPV4_CODE_EXACT_SET(_match)   \
    MEMSET(&(_match)->masks.icmpv4_code, 0xff, \
        sizeof(((_match)->masks).icmpv4_code))

/**
 * Clear the mask for icmpv4_code making that field inactive for the match
 */
#define OF_MATCH_MASK_ICMPV4_CODE_CLEAR(_match) \
    MEMSET(&(_match)->masks.icmpv4_code, 0, \
        sizeof(((_match)->masks).icmpv4_code))

/**
 * Test whether the match is exact for icmpv4_code
 */
#define OF_MATCH_MASK_ICMPV4_CODE_EXACT_TEST(_match) \
    OF_VARIABLE_IS_ALL_ONES(&(((_match)->masks).icmpv4_code))

/**
 * Test whether key icmpv4_code is being checked in the match
 */
#define OF_MATCH_MASK_ICMPV4_CODE_ACTIVE_TEST(_match) \
    OF_VARIABLE_IS_NON_ZERO(&(((_match)->masks).icmpv4_code))


/* Mask/value check/set macros for bsn_vrf */

/**
 * Set the mask for an exact match of bsn_vrf
 */
#define OF_MATCH_MASK_BSN_VRF_EXACT_SET(_match)   \
    MEMSET(&(_match)->masks.bsn_vrf, 0xff, \
        sizeof(((_match)->masks).bsn_vrf))

/**
 * Clear the mask for bsn_vrf making that field inactive for the match
 */
#define OF_MATCH_MASK_BSN_VRF_CLEAR(_match) \
    MEMSET(&(_match)->masks.bsn_vrf, 0, \
        sizeof(((_match)->masks).bsn_vrf))

/**
 * Test whether the match is exact for bsn_vrf
 */
#define OF_MATCH_MASK_BSN_VRF_EXACT_TEST(_match) \
    OF_VARIABLE_IS_ALL_ONES(&(((_match)->masks).bsn_vrf))

/**
 * Test whether key bsn_vrf is being checked in the match
 */
#define OF_MATCH_MASK_BSN_VRF_ACTIVE_TEST(_match) \
    OF_VARIABLE_IS_NON_ZERO(&(((_match)->masks).bsn_vrf))


/* Mask/value check/set macros for ip_ecn */

/**
 * Set the mask for an exact match of ip_ecn
 */
#define OF_MATCH_MASK_IP_ECN_EXACT_SET(_match)   \
    MEMSET(&(_match)->masks.ip_ecn, 0xff, \
        sizeof(((_match)->masks).ip_ecn))

/**
 * Clear the mask for ip_ecn making that field inactive for the match
 */
#define OF_MATCH_MASK_IP_ECN_CLEAR(_match) \
    MEMSET(&(_match)->masks.ip_ecn, 0, \
        sizeof(((_match)->masks).ip_ecn))

/**
 * Test whether the match is exact for ip_ecn
 */
#define OF_MATCH_MASK_IP_ECN_EXACT_TEST(_match) \
    OF_VARIABLE_IS_ALL_ONES(&(((_match)->masks).ip_ecn))

/**
 * Test whether key ip_ecn is being checked in the match
 */
#define OF_MATCH_MASK_IP_ECN_ACTIVE_TEST(_match) \
    OF_VARIABLE_IS_NON_ZERO(&(((_match)->masks).ip_ecn))


/* Mask/value check/set macros for bsn_global_vrf_allowed */

/**
 * Set the mask for an exact match of bsn_global_vrf_allowed
 */
#define OF_MATCH_MASK_BSN_GLOBAL_VRF_ALLOWED_EXACT_SET(_match)   \
    MEMSET(&(_match)->masks.bsn_global_vrf_allowed, 0xff, \
        sizeof(((_match)->masks).bsn_global_vrf_allowed))

/**
 * Clear the mask for bsn_global_vrf_allowed making that field inactive for the match
 */
#define OF_MATCH_MASK_BSN_GLOBAL_VRF_ALLOWED_CLEAR(_match) \
    MEMSET(&(_match)->masks.bsn_global_vrf_allowed, 0, \
        sizeof(((_match)->masks).bsn_global_vrf_allowed))

/**
 * Test whether the match is exact for bsn_global_vrf_allowed
 */
#define OF_MATCH_MASK_BSN_GLOBAL_VRF_ALLOWED_EXACT_TEST(_match) \
    OF_VARIABLE_IS_ALL_ONES(&(((_match)->masks).bsn_global_vrf_allowed))

/**
 * Test whether key bsn_global_vrf_allowed is being checked in the match
 */
#define OF_MATCH_MASK_BSN_GLOBAL_VRF_ALLOWED_ACTIVE_TEST(_match) \
    OF_VARIABLE_IS_NON_ZERO(&(((_match)->masks).bsn_global_vrf_allowed))


/* Mask/value check/set macros for in_phy_port */

/**
 * Set the mask for an exact match of in_phy_port
 */
#define OF_MATCH_MASK_IN_PHY_PORT_EXACT_SET(_match)   \
    MEMSET(&(_match)->masks.in_phy_port, 0xff, \
        sizeof(((_match)->masks).in_phy_port))

/**
 * Clear the mask for in_phy_port making that field inactive for the match
 */
#define OF_MATCH_MASK_IN_PHY_PORT_CLEAR(_match) \
    MEMSET(&(_match)->masks.in_phy_port, 0, \
        sizeof(((_match)->masks).in_phy_port))

/**
 * Test whether the match is exact for in_phy_port
 */
#define OF_MATCH_MASK_IN_PHY_PORT_EXACT_TEST(_match) \
    OF_VARIABLE_IS_ALL_ONES(&(((_match)->masks).in_phy_port))

/**
 * Test whether key in_phy_port is being checked in the match
 */
#define OF_MATCH_MASK_IN_PHY_PORT_ACTIVE_TEST(_match) \
    OF_VARIABLE_IS_NON_ZERO(&(((_match)->masks).in_phy_port))


/* Mask/value check/set macros for ofdpa_mpls_ach_channel */

/**
 * Set the mask for an exact match of ofdpa_mpls_ach_channel
 */
#define OF_MATCH_MASK_OFDPA_MPLS_ACH_CHANNEL_EXACT_SET(_match)   \
    MEMSET(&(_match)->masks.ofdpa_mpls_ach_channel, 0xff, \
        sizeof(((_match)->masks).ofdpa_mpls_ach_channel))

/**
 * Clear the mask for ofdpa_mpls_ach_channel making that field inactive for the match
 */
#define OF_MATCH_MASK_OFDPA_MPLS_ACH_CHANNEL_CLEAR(_match) \
    MEMSET(&(_match)->masks.ofdpa_mpls_ach_channel, 0, \
        sizeof(((_match)->masks).ofdpa_mpls_ach_channel))

/**
 * Test whether the match is exact for ofdpa_mpls_ach_channel
 */
#define OF_MATCH_MASK_OFDPA_MPLS_ACH_CHANNEL_EXACT_TEST(_match) \
    OF_VARIABLE_IS_ALL_ONES(&(((_match)->masks).ofdpa_mpls_ach_channel))

/**
 * Test whether key ofdpa_mpls_ach_channel is being checked in the match
 */
#define OF_MATCH_MASK_OFDPA_MPLS_ACH_CHANNEL_ACTIVE_TEST(_match) \
    OF_VARIABLE_IS_NON_ZERO(&(((_match)->masks).ofdpa_mpls_ach_channel))


/* Mask/value check/set macros for ofdpa_color */

/**
 * Set the mask for an exact match of ofdpa_color
 */
#define OF_MATCH_MASK_OFDPA_COLOR_EXACT_SET(_match)   \
    MEMSET(&(_match)->masks.ofdpa_color, 0xff, \
        sizeof(((_match)->masks).ofdpa_color))

/**
 * Clear the mask for ofdpa_color making that field inactive for the match
 */
#define OF_MATCH_MASK_OFDPA_COLOR_CLEAR(_match) \
    MEMSET(&(_match)->masks.ofdpa_color, 0, \
        sizeof(((_match)->masks).ofdpa_color))

/**
 * Test whether the match is exact for ofdpa_color
 */
#define OF_MATCH_MASK_OFDPA_COLOR_EXACT_TEST(_match) \
    OF_VARIABLE_IS_ALL_ONES(&(((_match)->masks).ofdpa_color))

/**
 * Test whether key ofdpa_color is being checked in the match
 */
#define OF_MATCH_MASK_OFDPA_COLOR_ACTIVE_TEST(_match) \
    OF_VARIABLE_IS_NON_ZERO(&(((_match)->masks).ofdpa_color))


/* Mask/value check/set macros for ofdpa_mpls_type */

/**
 * Set the mask for an exact match of ofdpa_mpls_type
 */
#define OF_MATCH_MASK_OFDPA_MPLS_TYPE_EXACT_SET(_match)   \
    MEMSET(&(_match)->masks.ofdpa_mpls_type, 0xff, \
        sizeof(((_match)->masks).ofdpa_mpls_type))

/**
 * Clear the mask for ofdpa_mpls_type making that field inactive for the match
 */
#define OF_MATCH_MASK_OFDPA_MPLS_TYPE_CLEAR(_match) \
    MEMSET(&(_match)->masks.ofdpa_mpls_type, 0, \
        sizeof(((_match)->masks).ofdpa_mpls_type))

/**
 * Test whether the match is exact for ofdpa_mpls_type
 */
#define OF_MATCH_MASK_OFDPA_MPLS_TYPE_EXACT_TEST(_match) \
    OF_VARIABLE_IS_ALL_ONES(&(((_match)->masks).ofdpa_mpls_type))

/**
 * Test whether key ofdpa_mpls_type is being checked in the match
 */
#define OF_MATCH_MASK_OFDPA_MPLS_TYPE_ACTIVE_TEST(_match) \
    OF_VARIABLE_IS_NON_ZERO(&(((_match)->masks).ofdpa_mpls_type))


/* Mask/value check/set macros for ofdpa_vrf */

/**
 * Set the mask for an exact match of ofdpa_vrf
 */
#define OF_MATCH_MASK_OFDPA_VRF_EXACT_SET(_match)   \
    MEMSET(&(_match)->masks.ofdpa_vrf, 0xff, \
        sizeof(((_match)->masks).ofdpa_vrf))

/**
 * Clear the mask for ofdpa_vrf making that field inactive for the match
 */
#define OF_MATCH_MASK_OFDPA_VRF_CLEAR(_match) \
    MEMSET(&(_match)->masks.ofdpa_vrf, 0, \
        sizeof(((_match)->masks).ofdpa_vrf))

/**
 * Test whether the match is exact for ofdpa_vrf
 */
#define OF_MATCH_MASK_OFDPA_VRF_EXACT_TEST(_match) \
    OF_VARIABLE_IS_ALL_ONES(&(((_match)->masks).ofdpa_vrf))

/**
 * Test whether key ofdpa_vrf is being checked in the match
 */
#define OF_MATCH_MASK_OFDPA_VRF_ACTIVE_TEST(_match) \
    OF_VARIABLE_IS_NON_ZERO(&(((_match)->masks).ofdpa_vrf))


/* Mask/value check/set macros for bsn_udf1 */

/**
 * Set the mask for an exact match of bsn_udf1
 */
#define OF_MATCH_MASK_BSN_UDF1_EXACT_SET(_match)   \
    MEMSET(&(_match)->masks.bsn_udf1, 0xff, \
        sizeof(((_match)->masks).bsn_udf1))

/**
 * Clear the mask for bsn_udf1 making that field inactive for the match
 */
#define OF_MATCH_MASK_BSN_UDF1_CLEAR(_match) \
    MEMSET(&(_match)->masks.bsn_udf1, 0, \
        sizeof(((_match)->masks).bsn_udf1))

/**
 * Test whether the match is exact for bsn_udf1
 */
#define OF_MATCH_MASK_BSN_UDF1_EXACT_TEST(_match) \
    OF_VARIABLE_IS_ALL_ONES(&(((_match)->masks).bsn_udf1))

/**
 * Test whether key bsn_udf1 is being checked in the match
 */
#define OF_MATCH_MASK_BSN_UDF1_ACTIVE_TEST(_match) \
    OF_VARIABLE_IS_NON_ZERO(&(((_match)->masks).bsn_udf1))


/* Mask/value check/set macros for bsn_udf0 */

/**
 * Set the mask for an exact match of bsn_udf0
 */
#define OF_MATCH_MASK_BSN_UDF0_EXACT_SET(_match)   \
    MEMSET(&(_match)->masks.bsn_udf0, 0xff, \
        sizeof(((_match)->masks).bsn_udf0))

/**
 * Clear the mask for bsn_udf0 making that field inactive for the match
 */
#define OF_MATCH_MASK_BSN_UDF0_CLEAR(_match) \
    MEMSET(&(_match)->masks.bsn_udf0, 0, \
        sizeof(((_match)->masks).bsn_udf0))

/**
 * Test whether the match is exact for bsn_udf0
 */
#define OF_MATCH_MASK_BSN_UDF0_EXACT_TEST(_match) \
    OF_VARIABLE_IS_ALL_ONES(&(((_match)->masks).bsn_udf0))

/**
 * Test whether key bsn_udf0 is being checked in the match
 */
#define OF_MATCH_MASK_BSN_UDF0_ACTIVE_TEST(_match) \
    OF_VARIABLE_IS_NON_ZERO(&(((_match)->masks).bsn_udf0))


/* Mask/value check/set macros for ipv6_nd_tll */

/**
 * Set the mask for an exact match of ipv6_nd_tll
 */
#define OF_MATCH_MASK_IPV6_ND_TLL_EXACT_SET(_match)   \
    MEMSET(&(_match)->masks.ipv6_nd_tll, 0xff, \
        sizeof(((_match)->masks).ipv6_nd_tll))

/**
 * Clear the mask for ipv6_nd_tll making that field inactive for the match
 */
#define OF_MATCH_MASK_IPV6_ND_TLL_CLEAR(_match) \
    MEMSET(&(_match)->masks.ipv6_nd_tll, 0, \
        sizeof(((_match)->masks).ipv6_nd_tll))

/**
 * Test whether the match is exact for ipv6_nd_tll
 */
#define OF_MATCH_MASK_IPV6_ND_TLL_EXACT_TEST(_match) \
    OF_VARIABLE_IS_ALL_ONES(&(((_match)->masks).ipv6_nd_tll))

/**
 * Test whether key ipv6_nd_tll is being checked in the match
 */
#define OF_MATCH_MASK_IPV6_ND_TLL_ACTIVE_TEST(_match) \
    OF_VARIABLE_IS_NON_ZERO(&(((_match)->masks).ipv6_nd_tll))


/* Mask/value check/set macros for bsn_udf2 */

/**
 * Set the mask for an exact match of bsn_udf2
 */
#define OF_MATCH_MASK_BSN_UDF2_EXACT_SET(_match)   \
    MEMSET(&(_match)->masks.bsn_udf2, 0xff, \
        sizeof(((_match)->masks).bsn_udf2))

/**
 * Clear the mask for bsn_udf2 making that field inactive for the match
 */
#define OF_MATCH_MASK_BSN_UDF2_CLEAR(_match) \
    MEMSET(&(_match)->masks.bsn_udf2, 0, \
        sizeof(((_match)->masks).bsn_udf2))

/**
 * Test whether the match is exact for bsn_udf2
 */
#define OF_MATCH_MASK_BSN_UDF2_EXACT_TEST(_match) \
    OF_VARIABLE_IS_ALL_ONES(&(((_match)->masks).bsn_udf2))

/**
 * Test whether key bsn_udf2 is being checked in the match
 */
#define OF_MATCH_MASK_BSN_UDF2_ACTIVE_TEST(_match) \
    OF_VARIABLE_IS_NON_ZERO(&(((_match)->masks).bsn_udf2))


/* Mask/value check/set macros for bsn_udf5 */

/**
 * Set the mask for an exact match of bsn_udf5
 */
#define OF_MATCH_MASK_BSN_UDF5_EXACT_SET(_match)   \
    MEMSET(&(_match)->masks.bsn_udf5, 0xff, \
        sizeof(((_match)->masks).bsn_udf5))

/**
 * Clear the mask for bsn_udf5 making that field inactive for the match
 */
#define OF_MATCH_MASK_BSN_UDF5_CLEAR(_match) \
    MEMSET(&(_match)->masks.bsn_udf5, 0, \
        sizeof(((_match)->masks).bsn_udf5))

/**
 * Test whether the match is exact for bsn_udf5
 */
#define OF_MATCH_MASK_BSN_UDF5_EXACT_TEST(_match) \
    OF_VARIABLE_IS_ALL_ONES(&(((_match)->masks).bsn_udf5))

/**
 * Test whether key bsn_udf5 is being checked in the match
 */
#define OF_MATCH_MASK_BSN_UDF5_ACTIVE_TEST(_match) \
    OF_VARIABLE_IS_NON_ZERO(&(((_match)->masks).bsn_udf5))


/* Mask/value check/set macros for bsn_udf4 */

/**
 * Set the mask for an exact match of bsn_udf4
 */
#define OF_MATCH_MASK_BSN_UDF4_EXACT_SET(_match)   \
    MEMSET(&(_match)->masks.bsn_udf4, 0xff, \
        sizeof(((_match)->masks).bsn_udf4))

/**
 * Clear the mask for bsn_udf4 making that field inactive for the match
 */
#define OF_MATCH_MASK_BSN_UDF4_CLEAR(_match) \
    MEMSET(&(_match)->masks.bsn_udf4, 0, \
        sizeof(((_match)->masks).bsn_udf4))

/**
 * Test whether the match is exact for bsn_udf4
 */
#define OF_MATCH_MASK_BSN_UDF4_EXACT_TEST(_match) \
    OF_VARIABLE_IS_ALL_ONES(&(((_match)->masks).bsn_udf4))

/**
 * Test whether key bsn_udf4 is being checked in the match
 */
#define OF_MATCH_MASK_BSN_UDF4_ACTIVE_TEST(_match) \
    OF_VARIABLE_IS_NON_ZERO(&(((_match)->masks).bsn_udf4))


/* Mask/value check/set macros for bsn_udf7 */

/**
 * Set the mask for an exact match of bsn_udf7
 */
#define OF_MATCH_MASK_BSN_UDF7_EXACT_SET(_match)   \
    MEMSET(&(_match)->masks.bsn_udf7, 0xff, \
        sizeof(((_match)->masks).bsn_udf7))

/**
 * Clear the mask for bsn_udf7 making that field inactive for the match
 */
#define OF_MATCH_MASK_BSN_UDF7_CLEAR(_match) \
    MEMSET(&(_match)->masks.bsn_udf7, 0, \
        sizeof(((_match)->masks).bsn_udf7))

/**
 * Test whether the match is exact for bsn_udf7
 */
#define OF_MATCH_MASK_BSN_UDF7_EXACT_TEST(_match) \
    OF_VARIABLE_IS_ALL_ONES(&(((_match)->masks).bsn_udf7))

/**
 * Test whether key bsn_udf7 is being checked in the match
 */
#define OF_MATCH_MASK_BSN_UDF7_ACTIVE_TEST(_match) \
    OF_VARIABLE_IS_NON_ZERO(&(((_match)->masks).bsn_udf7))


/* Mask/value check/set macros for bsn_udf6 */

/**
 * Set the mask for an exact match of bsn_udf6
 */
#define OF_MATCH_MASK_BSN_UDF6_EXACT_SET(_match)   \
    MEMSET(&(_match)->masks.bsn_udf6, 0xff, \
        sizeof(((_match)->masks).bsn_udf6))

/**
 * Clear the mask for bsn_udf6 making that field inactive for the match
 */
#define OF_MATCH_MASK_BSN_UDF6_CLEAR(_match) \
    MEMSET(&(_match)->masks.bsn_udf6, 0, \
        sizeof(((_match)->masks).bsn_udf6))

/**
 * Test whether the match is exact for bsn_udf6
 */
#define OF_MATCH_MASK_BSN_UDF6_EXACT_TEST(_match) \
    OF_VARIABLE_IS_ALL_ONES(&(((_match)->masks).bsn_udf6))

/**
 * Test whether key bsn_udf6 is being checked in the match
 */
#define OF_MATCH_MASK_BSN_UDF6_ACTIVE_TEST(_match) \
    OF_VARIABLE_IS_NON_ZERO(&(((_match)->masks).bsn_udf6))


/* Mask/value check/set macros for bsn_udf3 */

/**
 * Set the mask for an exact match of bsn_udf3
 */
#define OF_MATCH_MASK_BSN_UDF3_EXACT_SET(_match)   \
    MEMSET(&(_match)->masks.bsn_udf3, 0xff, \
        sizeof(((_match)->masks).bsn_udf3))

/**
 * Clear the mask for bsn_udf3 making that field inactive for the match
 */
#define OF_MATCH_MASK_BSN_UDF3_CLEAR(_match) \
    MEMSET(&(_match)->masks.bsn_udf3, 0, \
        sizeof(((_match)->masks).bsn_udf3))

/**
 * Test whether the match is exact for bsn_udf3
 */
#define OF_MATCH_MASK_BSN_UDF3_EXACT_TEST(_match) \
    OF_VARIABLE_IS_ALL_ONES(&(((_match)->masks).bsn_udf3))

/**
 * Test whether key bsn_udf3 is being checked in the match
 */
#define OF_MATCH_MASK_BSN_UDF3_ACTIVE_TEST(_match) \
    OF_VARIABLE_IS_NON_ZERO(&(((_match)->masks).bsn_udf3))


#endif /* Base header file */
